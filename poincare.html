<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title> Hyperbolic Geometry Art </title>
      <link rel="icon" href="logo.svg" type="image/svg+xml">
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@200&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <link rel="stylesheet" href="main.css">
   </head>
   <body>
      <div class="container">
         <!-- Toggle button for small screens -->
         <div class="toggle-button" id="toggleButton">
            <img src="asset/tumpalLogo.svg" alt="SVG Image Description">
            <span style="margin-left: auto; margin-right: auto;"> Geometry of Batik </span>
            <span style="margin-left: auto; margin-right: 20px;"> &#9776; </span> 
         </div>
         <!-- Side Navigation Bar -->
         <div class="sidenav" id="sidenav">
            <div style= "display: flex; font-size: 24px;">
               <img src="asset/tumpalLogo.svg" alt="SVG Image Description">
               <span style="margin-left: 10px;"> Geometry of Batik  
               <span>
            </div>
            <hr>
            <script src="nav.js"></script>
         </div>
         <!-- Main Content Area -->
         <div class="main-content">
         <h1 > Poincare Disk Kawung </h1>
         
            <div id="svg-container"></div>
         <figure>
            <details style="margin-top: 5px;">
               <summary style="text-align: center;"> <span> Interactive Image  </span> </summary>  
               <select name="Motives" id="motives" class="btns" style="margin-top: 10px;" >
                  <option value="pentagonFourVertices"> pentagonFourVertices </option>
                  <option value="squareFiveVertices"> squareFiveVertices </option>
                  <option value="hexagonFourVertices"> hexagonFourVertices </option>
               </select>
               <select name="theme" id="themes" class="btns" >
                  <option value="oldJava">Old Java </option>
                  <option value="batavia">Batavia </option>
                  <option value="green"> Green </option>
                  <option value="megaMendung2" selected> Mega Mendung </option>
               </select>
               <button id="download-btn"> <i class="fa fa-download"></i>  Download SVG </span> </button>
            </details>
            <div style="text-align: center; margin-top: 10px;">
                    <button id="left-button" onclick="if (currentPattern === 'pentagonFourVertices') {
          currentPattern = 'hexagonFourVertices';
          selectBox.value = 'hexagonFourVertices';
        } 
        else if (currentPattern === 'squareFiveVertices') {
          currentPattern = 'pentagonFourVertices';
          selectBox.value = 'pentagonFourVertices';
        } 
        else if (currentPattern === 'hexagonFourVertices') {
          currentPattern = 'squareFiveVertices';
          selectBox.value = 'squareFiveVertices';
        }  redraw();"><</button>
         <button id="right-button" onclick="
        if (currentPattern === 'pentagonFourVertices') {
          currentPattern = 'squareFiveVertices';
          selectBox.value = 'squareFiveVertices';
        } 
        else if (currentPattern === 'squareFiveVertices') {
          currentPattern = 'hexagonFourVertices';
          selectBox.value = 'hexagonFourVertices';
        } 
        else if (currentPattern === 'hexagonFourVertices') {
          currentPattern = 'pentagonFourVertices';
          selectBox.value = 'pentagonFourVertices';
        }  redraw();">></button>
               </div>
         </figure>
         
         <article style="width: 80%; text-align: center; margin: auto;">
         <h2 style="text-align: left;"> Drawing the Impossible: Exploring Hyperbolic Geometry </h2>            
         <p style="text-align: left;"> People often view certain tasks as impossible‚Äîuntil an innovator steps in, challenges the boundaries of belief, and turns the improbable into reality. For instance, flying was considered as impossible until the Wright brothers successfully flew their first airplane in 1903. Similarly, for centuries, regular tessellations were thought to include only squares, triangles, and hexagons. This belief persisted until Lobachevsky, Gauss, and Bolyai introduced the groundbreaking concept of hyperbolic geometry, revealing an entirely new world of possibilities.  </p>
         <p style="text-align: left;"> Before we dive into the world of hyperbolic geometry, let's first explore Euclidean and Elliptic geometry. The main difference between these geometries is their curvature. Euclidean geometry, the one we commonly learn in schools, has zero curvature. We can think of it as a flat sheet of paper. On the other hand, elliptical geometry has positive curvature, which we can visualize as the surface of a ball or the Earth. In contrast, hyperbolic geometry has negative curvature, and we can imagine it as the surface of a saddle.    </p>
         <p style="text-align: left;"> To better understand hyperbolic geometry, we use models and projections. This is similar to what we do with Earth: while the Earth is spherical, we project it onto a 2D flat surface to make it easier for us to read and write about it. Similarly, in hyperbolic geometry, we use the Poincar√© disk model. The Poincar√© disk model has several key characteristics that make it both interesting and aesthetically pleasing. First, it uses a unit circle. Second, the shapes at the center of the disk appear larger, while those near the edges appear smaller. Third, it is conformal, meaning it preserves angles. These combinations, if used by great artists, can create very unique art. One of the most famous examples is <a href="https://en.wikipedia.org/wiki/Circle_Limit_III">M.C Escher Circle Limit</a>  </p>
         <p style="text-align: left;"> In the following text, we will explore methods to combine hyperbolic geometry with the traditional batik kawung motif.   </p>

         <h2 style="text-align: left;"> Tiling Design </h2>
         
         <p style="text-align: left;"> First, we want to determine which regular tessellation {n, k} will produce an aesthetically pleasing result in the hyperbolic plane. An {n, k} tessellation means that an n-sided polygon meets k other polygons at a single vertex. For example, a {3,6} tessellation means that six triangles meet at a vertex.

The key concept is that in Euclidean space, the sum of the interior angles of a triangle is always 180 degrees, whereas in hyperbolic space, it is less than 180 degrees. This fundamental difference allows for tessellations that are impossible in Euclidean space to exist in hyperbolic space.

For instance, four pentagons cannot tessellate in Euclidean space because their angles sum to more than 360 degrees, leaving no room for a fourth pentagon. However, in hyperbolic space, where angles sum to less than their Euclidean counterparts, this tessellation becomes possible.  </p>
         <p style="text-align: left;"> To determine whether a polygon will tesselate in which place, we can use the following neat formula. First, we know than in Euclidean plane, sum of all angle in polygon can be described as (n-2) * 180 degree. For example, sum of all angles in triangle are 180 degrees. On the other hand, sum of all angles in square are 360 degrees. For pentagon, the sum of all angles are 540 degrees. The formula will hold for polygon with more sides.    </p>

         <p style="text-align: center">   \[ SumOfInteriorAngle =
  (n - 2) \times 180^\circ
  \] </p>

         <p style="text-align: left;"> For a tessellation {n,k}, there are k regular polygons at each vertex. So the angle at each vertex is 360¬∞/k. Since a regular n-gon has n equal angles, each being 360¬∞/k, therefore the angle sum is n360¬∞/k </p>

         <p style="text-align: center">    \[
            SumOfInteriorAngle =
  \frac{n \times 360^\circ}{k}
  \] </p>

         <p style="text-align: left;"> If we substitute first equation to second equation we get this formula: </p>
<p style="text-align: center">
  \[
  (n - 2) \times 180^\circ = \frac{n \times 360^\circ}{k}
  \]
</p>
            


            
         <p style="text-align: justify;"> We can ascertain whether the {n, k} tessellation (Note: a polygon with n sides meeting k other polygons at each vertex) will form a tessellation in the Euclidean plane, the hyperbolic plane, or the elliptic plane by utilizing the following formula:  </p>
         <p style=" overflow-x: scroll;"> For Euclidean tessellation,  \( \frac{1}{n} + \frac{1}{k} = \frac{1}{2}  \) </p>
         <p style=" overflow-x: scroll;"> For Hyperbolic tessellation,  \( \frac{1}{n} + \frac{1}{k} < \frac{1}{2}  \) </p>
         <p style=" overflow-x: scroll;"> For Elliptical tessellation,  \( \frac{1}{n} + \frac{1}{k} > \frac{1}{2}  \) </p>

         <p style="text-align: left;"> Using the equation mentioned above, we can determine which polygons can tessellate neatly in the hyperbolic plane. The author has tested various combinations of 
ùëõ and ùëò
k, ranging from 1 to 10, and found that the {5,4} tessellation (where four pentagons meet at one vertex) and the {4,5} tessellation (where five quadrilaterals meet at one vertex) satisfy the equation for hyperbolic tessellation. Additionally, these patterns produce visually pleasing results. </p>


         <h2 style="text-align: justify; color: #493118; font-weight: bold;"> Generalization of Batik Kawung </h2>
         <p style="text-align: left;"> In order to decorate hyperbolic tiling with batik kawung, we need to find method to draw batik Kawung given a set of points. Author propose the following algorithm to generate kawung pattern. </p>
         <ol>
         <li><p style="text-align: justify;"> Any set of vertices can be decorated with batik Kawung using this algorithm. </p></li>
         <li><p style="text-align: justify;"> Initially, we identify the polygon's center by computing the average of the x-coordinates and y-coordinates of its points. This provides us with the coordinates for the center of the vertices </p> </li>
         <li><p style="text-align: justify;"> Subsequently, a Quadratic Bezier curve is drawn, commencing from the center as the starting point, utilizing the midpoints of the vertices as control points, and ending at the vertices themselves</p> </li>
         <li><p style="text-align: justify;"> This process is reiterated by repeating step #3 for each subsequent vertex.</p> </li>
         </ol>
         <p style="text-align: left;"> You can refer to image below to see the algorithm in action. You can try drag the gray circles to change the vertices, and kawung pattern will be dynamically updated according to the circles position. </p>
   
<!-- <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
  <svg id="svgCanvasDraggable" viewBox="0 0 400 400" width="400px" height="400px" xmlns="http://www.w3.org/2000/svg" 
       style="max-width: 100%; height: auto;">
    <polygon id="quadrilateral" points="150,250 250,250 250,150 150,150" fill="none" stroke="gray" stroke-width="1"/>
    <circle id="pointA" class="point" cx="150" cy="250" r="10" fill="gray"/>
    <circle id="pointB" class="point" cx="250" cy="250" r="10" fill="gray"/>
    <circle id="pointC" class="point" cx="250" cy="150" r="10" fill="gray"/>
    <circle id="pointD" class="point" cx="150" cy="150" r="10" fill="gray"/>
  </svg>
</div> -->

  <svg id="svgCanvasDraggable" viewBox="0 0 400 400" width="400px" height="400px" xmlns="http://www.w3.org/2000/svg">
    <!-- Polygon representing the quadrilateral -->
    <polygon id="quadrilateral" points="100,300 300,300 300,100 100,100" fill="none" stroke="gray" stroke-width="1"/>
    
    <!-- Draggable points -->
    <circle id="pointA" class="point" cx="100" cy="300" r="10" fill="gray"/>
    <circle id="pointB" class="point" cx="300" cy="300" r="10" fill="gray"/>
    <circle id="pointC" class="point" cx="300" cy="100" r="10" fill="gray"/>
    <circle id="pointD" class="point" cx="100" cy="100" r="10" fill="gray"/>
  </svg>
         <div style="text-align: center;">
              <canvas id="myCanvas" style="display: block; margin: auto;"></canvas>
         </div>
         <button id="refresh-btn"> <i class="fa fa-refresh"></i>  Replay Animation </span> </button>

         <h2 style="text-align: justify; color: #493118; font-weight: bold;"> Exhibit </h2>  
         <img src="asset/jewelryKawungBall.png" alt="Apollonian Kawung Necklace" style="display: flex;
     justify-content: center;
     height: 300px;
     width: 300px;
     margin: auto;" >
         <p style="text-align: justify;"> Presenting the Kawung Ball by The Geometry of Batik Team. With the mathematical model in hand, creating a 3D model becomes a straightforward process. The resulting 3D model serves as the foundation for crafting this necklace using the lost wax casting method in our exhibit </p>
         <h2 style="text-align: justify; color: #493118; font-weight: bold;"> References </h2>
         <ul>
         <li><p style="text-align: justify;"> <a href="http://aleph0.clarku.edu/~djoyce/poincare/poincare.html">Hyperbolic Tessellation</a> </p></li>
         <li><p style="text-align: justify;"> <a href="https://codegolf.stackexchange.com/questions/55848/plot-a-hyperbolic-plane-tessellation"> Don Hatch's code for hyperbolic plane tessellation </a> </p> </li>
         </ul>
         </article>
         </div>
      </div>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="hyperbolicDataset.js"> </script>
      <script src="js/batikGeometry.js"></script>
      <script src="js/poincare.js"> </script>
      <script src="js/mainUI.js"></script> 
      <script src="js/animationToolkit.js"></script>
      <script src="js/animationIrregularPolygon.js"></script>

                  <script>
    const svgDraggable = document.getElementById('svgCanvasDraggable');
    const quadrilateral = document.getElementById('quadrilateral');

    const points = {
      A: document.getElementById('pointA'),
      B: document.getElementById('pointB'),
      C: document.getElementById('pointC'),
      D: document.getElementById('pointD'),
    };

    let draggingPoint = null;

    // Helper Function to find the midpoint of two points
    function midpoint(x1, x2, split = 0.5) {
      dx = x2 - x1;
      return x1 + dx * split;
    }
    
    function dist(x1,y1, x2, y2){
        return Math.sqrt((x1-x2)**2 + (y1-y2)**2);
    }

    function drawArbitraryKawung2(Points, x, y, r =200, rotDeg= 0, mainColor=themes["oldJava"].mainColor, secondaryColor=themes["oldJava"].secondaryColor, strokeColor = themes["oldJava"].strokeColor, use_outline=false){  
    let container = document.createElementNS('http://www.w3.org/2000/svg', "g");
    container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg}) scale(${r/200} , ${r/200})`);
    // svgDraggable.appendChild(container);
    svgDraggable.insertBefore(container, points.A)
    let outline = document.createElementNS('http://www.w3.org/2000/svg', "path");
    outline_sentence = `M ${Points[0][0]}, ${Points[0][1]} `;
    container.setAttribute("id", "kawung");


    // Get center
    xc = 0;
    yc = 0;
    minY = Points[0][1];
    maxY = Points[0][1];
    for (let i=0; i < Points.length; i++){
      xc += Points[i][0];
      yc += Points[i][1];
      if (i>0){
        outline_sentence += `L${Points[i][0]}, ${Points[i][1]} `;
      }
      if (Points[i][1] < minY){
        minY = Points[i][1];
      }

     if (Points[i][1] > maxY){
        maxY = Points[i][1];
      }



    }

    outline_sentence += 'Z';
    outline.setAttribute("d", outline_sentence);
    outline.setAttribute("fill", "none");
    outline.setAttribute("stroke",mainColor);
    outline.setAttribute("stroke-width", 1);
    if (use_outline){
        container.appendChild(outline);
    }

    xc = xc / Points.length;
    yc = yc / Points.length;
    // yc = (0.65 * maxY) ;
    split = 0.5;

    // Points = sortPointsClockwise(Points);

    for (let i=0; i < Points.length ; i++){
        if (i < Points.length -1) {

            dp = dist(Points[i][0], Points[i][1], xc, yc);
            dp2 = dist(Points[i+1][0], Points[i+1][1], xc, yc);
            // split = dp / (dp + dp2);


            new_x = midpoint(Points[i][0],Points[i+1][0], split);
            new_y = midpoint(Points[i][1],Points[i+1][1], split);
        }
        else {

            dp = dist(Points[i][0], Points[i][1], xc, yc);
            dp2 = dist(Points[0][0], Points[0][1], xc, yc);
            // split = dp / (dp + dp2);

            new_x = midpoint(Points[i][0],Points[0][0], split);
            new_y = midpoint(Points[i][1],Points[0][1], split);    
        }
    
        if (i === 0){
            dp = dist(Points[i][0], Points[i][1], xc, yc);
            dp2 = dist(Points[Points.length -1][0], Points[Points.length -1][1], xc, yc);
            // split = dp / (dp + dp2);

            new_x2 = midpoint(Points[i][0],Points[Points.length -1][0], split);
            new_y2 = midpoint(Points[i][1],Points[Points.length -1][1], split);  
        }
        else {
            dp = dist(Points[i][0], Points[i][1], xc, yc);
            dp2 = dist(Points[i -1][0], Points[i -1][1], xc, yc);
            // split = dp / (dp + dp2);
            new_x2 = midpoint(Points[i][0], Points[i-1][0]);
            new_y2 = midpoint(Points[i][1], Points[i-1][1]);  
        }

        // Quadratic Bezier Curve
        kawung_part = document.createElementNS('http://www.w3.org/2000/svg', "path");
        kawung_part.setAttribute("d", `M ${xc} ${yc} Q${new_x} ${new_y} ${Points[i][0]} ${Points[i][1]} Q${new_x2} ${new_y2} ${xc} ${yc}`);
        kawung_part.setAttribute("stroke", strokeColor);
        kawung_part.setAttribute("fill", mainColor);
        kawung_part.setAttribute("stroke-width", 0.15);
        container.appendChild(kawung_part);
    
        circle = document.createElementNS('http://www.w3.org/2000/svg', "circle");
        circle.setAttribute("cx", xc + 0.80 * (Points[i][0] - xc)); // x-coordinate of the center
        circle.setAttribute("cy", yc + 0.80 * (Points[i][1] - yc)); // y-coordinate of the center
        circle.setAttribute("r", 0.04 * Math.sqrt(  (Points[i][0] - xc) ** 2 + (Points[i][1] - yc) ** 2));   // radius
        // circle.setAttribute('stroke', secondary_colour);
        circle.setAttribute("fill", secondaryColor); // fill color
        container.appendChild(circle);
    }
}

                     

    // Update the polygon points when a point is moved
    function updateQuadrilateral() {
      const newPoints = [
        `${points.A.cx.baseVal.value},${points.A.cy.baseVal.value}`,
        `${points.B.cx.baseVal.value},${points.B.cy.baseVal.value}`,
        `${points.C.cx.baseVal.value},${points.C.cy.baseVal.value}`,
        `${points.D.cx.baseVal.value},${points.D.cy.baseVal.value}`
      ];
      quadrilateral.setAttribute('points', newPoints.join(' '));

      cX = (points.A.cx.baseVal.value + points.B.cx.baseVal.value + points.C.cx.baseVal.value + points.D.cx.baseVal.value) / 4;
      cY = (points.A.cy.baseVal.value + points.B.cy.baseVal.value + points.C.cy.baseVal.value + points.D.cy.baseVal.value) / 4;

      dataset = [
         [points.A.cx.baseVal.value - cX ,points.A.cy.baseVal.value - cY]
        ,[points.B.cx.baseVal.value - cX ,points.B.cy.baseVal.value - cY]
        ,[points.C.cx.baseVal.value - cX ,points.C.cy.baseVal.value - cY]
        ,[points.D.cx.baseVal.value - cX ,points.D.cy.baseVal.value - cY]

      ];
      const element = document.getElementById('kawung');
      if (element) {
        element.remove();
      }
      
      drawArbitraryKawung2(dataset, cX, cY, 200, 0, "#78a0ce", "white", "black");

    }




                     


    // Get correct mouse/touch position
    function getEventPosition(event) {
      const rect = svgDraggable.getBoundingClientRect();
      if (event.touches) {
        return {
          x: event.touches[0].clientX - rect.left,
          y: event.touches[0].clientY - rect.top
        };
      }
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }


    // Start dragging (mousedown / touchstart)
    function startDrag(event) {
      event.preventDefault();
      const target = event.target;
      if (target.classList.contains('point')) {
        draggingPoint = target;
      }
    }

    // Dragging (mousemove / touchmove)
    function drag(event) {
      if (!draggingPoint) return;
      event.preventDefault();

      const pos = getEventPosition(event);
      draggingPoint.setAttribute('cx', pos.x);
      draggingPoint.setAttribute('cy', pos.y);

      updateQuadrilateral();
    }

    // Stop dragging (mouseup / touchend)
    function endDrag() {
      draggingPoint = null;
    }


    // Handle mouse events
    svgDraggable.addEventListener('mousedown', (e) => {
      if (e.target.classList.contains('point')) {
        draggingPoint = e.target;
      }
    });

    svgDraggable.addEventListener('mousemove', (e) => {
      if (draggingPoint) {
        const rect = svgDraggable.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        draggingPoint.setAttribute('cx', mouseX);
        draggingPoint.setAttribute('cy', mouseY);

        updateQuadrilateral();
      }
    });

    svgDraggable.addEventListener('mouseup', () => {
      draggingPoint = null;
    });

    svgDraggable.addEventListener('mouseleave', () => {
      draggingPoint = null;
    });

    svgDraggable.addEventListener('touchstart', startDrag, { passive: false });
    svgDraggable.addEventListener('touchmove', drag, { passive: false });
    svgDraggable.addEventListener('touchend', endDrag);

    updateQuadrilateral();






  </script>
   </body>
</html>
