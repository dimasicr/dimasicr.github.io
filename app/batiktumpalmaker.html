<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title> Batik Tumpal Maker </title>
      <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@200&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <link rel="stylesheet" href="/main.css">

</head>
<body>
<div class="container">
    <!-- Toggle button for small screens -->
    <div class="toggle-button" id="toggleButton">
        <img src="/asset/tumpalLogo.svg" alt="SVG Image Description">
        <span style="margin-left: auto; margin-right: auto;">Geometry of Batik</span>
        <span style="margin-left: auto; margin-right: 20px;">&#9776;</span> 
    </div>

    <!-- Side Navigation Bar -->
    <div class="sidenav" id="sidenav">
        <div style="display: flex; font-size: 24px;">
            <img src="/asset/tumpalLogo.svg" alt="SVG Image Description">
            <span style="margin-left: 10px;">Geometry of Batik</span>
        </div>
        <hr>
        <script src="/nav.js"></script>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <h1>Batik Tumpal Maker</h1>

        <div class="svg-container" id="svg-container">
            <svg id="svgcontainer" width="400" height="400" viewBox="0 0 400 400"></svg>
        </div>
            <button id="download-btn">
                <i class="fa fa-download"></i> Download SVG
            </button>
        <h2>How to Use</h2>
        <p>
            You can create a variety of fascinating patterns using our tessellation tool! 
            Simply hover over the side of a polygon and click to add a new motif—voilà, 
            your design expands effortlessly. Don't worry about making mistakes; you can 
            easily remove unwanted patterns using the remove option.
        </p>
        <p>Need some inspiration? Try these ideas:</p>
        <ul>
            <li>A full design made entirely of hexagons</li>
            <li>A pattern composed entirely of squares</li>
            <li>A pattern composed entirely of triangles</li>
            <li>A creative mix of squares and triangles</li>
        </ul>
    </div>
</div>

  <script>

const svgURI = 'http://www.w3.org/2000/svg';
    const svg = document.getElementById("svgcontainer");
    bg_rect = document.createElementNS(svgURI, "rect");
    bg_rect.setAttribute("width", "100%");
    bg_rect.setAttribute("height", "100%");
    bg_rect.setAttribute("fill", "#38445a");
    svg.appendChild(bg_rect);


function removeSvgChildById(svgContainer, targetId) {
  // Get all child elements
  const children = svgContainer.children;

  // Loop through children in reverse and remove the ones with the matching ID
  for (let i = children.length - 1; i >= 0; i--) {
    if (children[i].getAttribute("id") === targetId) {
      svgContainer.removeChild(children[i]);
    }
  }
}

function removeTransparentSVGElements(svgElement) {
  // Find all child elements of the SVG (path, circle, rect, etc.)
  const childElements = svgElement.querySelectorAll("*");

  childElements.forEach((element) => {
    const fill = element.getAttribute("fill");

    // Check if the fill is 'transparent' or an equivalent value
    if (fill === "transparent" || (fill === null && window.getComputedStyle(element).fill === "rgba(0, 0, 0, 0)")) {
      // If fill is transparent, remove the element
      element.remove();
    }
  });
}


  function getheight(wp){
     return Math.sin(60 * 2 * Math.PI/ 360) * wp;
  }


function drawTumpal(x, y, id = 123, s = 200, trig_degree = 45, rotDeg= 0, mainColor="#b49084", secondaryColor="#38445a", strokeColor = "gold", use_outline=false, tertiaryColor = "gold", use_middle_upper=true){  
    let container = document.createElementNS(svgURI, "g");
    container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
    container.setAttribute("stroke-width", 0.1);
    container.setAttribute("id", id);
    svg.appendChild(container);

    const h = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s);
    let outline = document.createElementNS(svgURI, "path");
    outline_sentence = `M0 0  ${0.5 * s} ${h}  ${-0.5 * s} ${h} Z`;
    outline.setAttribute("d", outline_sentence);
    outline.setAttribute("fill", "none");
    outline.setAttribute("stroke", strokeColor);
    if (use_outline){
        container.appendChild(outline);
    }
    if (trig_degree === 30) {
        R = s /15;
    }
    else if (trig_degree === 18){
        R = s / 20;
    }
    else if (trig_degree === 15){
        R = s / 25;
    }
    else if (trig_degree === 22.5){
        R = s / 20;
    }
    else {
        R = s / 10;
    }

    Xc = 0.5 * s - R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI)
    
    tpl_pth = `M0 ${h}  C ${Xc * 0.5} ${h}  ${Xc * 0.5} ${h - 2*R} ${Xc} ${h - 2* R} A${R} ${R} 0 0 1 ${Xc} ${h} A ${0.5 * R} ${0.5* R} 0 0 1 ${Xc} ${h - R} C${Xc - R} ${h - R} ${Xc - R} ${h}  ${Xc - 2 * R} ${h} Z`;
    tpl = document.createElementNS(svgURI, "path");
    tpl.setAttribute("d", tpl_pth);
    tpl.setAttribute("fill", mainColor);
    tpl.setAttribute("stroke", strokeColor);
    container.appendChild(tpl);


    tpl2 = tpl.cloneNode(true);
    tpl2.setAttribute("transform", "scale(-1 1)");
    container.appendChild(tpl2);


    tpl3 = tpl.cloneNode(true);
    tpl3.setAttribute("transform", `rotate(90 0 ${h}) scale(-1 1)`);
    tpl4 = tpl.cloneNode(true);
    tpl4.setAttribute("transform", `rotate(-90 0 ${h})`);

    tpl3.setAttribute("fill", tertiaryColor);
    tpl4.setAttribute("fill", tertiaryColor);

    if (mainColor === "#b49084") {
        tpl3.setAttribute("fill", "#e8eadd");
        tpl4.setAttribute("fill", "#e8eadd");
    }

    else if (mainColor === "#6ca1d2") {
        tpl3.setAttribute("fill", "#cddae8");
        tpl4.setAttribute("fill", "#cddae8");
    }
    else if (mainColor === "#c8c8cf") {
        tpl3.setAttribute("fill", "#F7F0F5");
        tpl4.setAttribute("fill", "#F7F0F5");
    }



        if (trig_degree === 60) {
            R_new = 2 * R;
        }
        else if (trig_degree === 45) {
            R_new = R;
        }
        else if (trig_degree === 67.5) {
            R_new = 2.5 * R;
        }
        else if (trig_degree === 75) {
            R_new = 2.5 * R;
        }

        else if (trig_degree === 54) {
            R_new = 1.5  * R;
        }

        else if (trig_degree === 72) {
            R_new = 2.5  * R;
        }

        else {
            R_new = R;
        }

        if (trig_degree !== 30 && trig_degree !== 18 && trig_degree !== 22.5 && trig_degree !== 15){
            // container.appendChild(tpl3);
            // container.appendChild(tpl4);
            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("d", `M 0 0 C 0 ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new}  ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new} ${h - Xc - R - 0.4 * R_new} A${0.2 * R_new} ${0.2 * R_new} 0 0 0 ${0} ${h - Xc - R - 0.4 * R_new} A${0.4 * R_new} ${0.4 * R_new} 0 0 0 ${0.8 * R_new} ${ h - Xc - R - 0.4 * R_new} C${0.8 * R_new} ${0.5 * (h - Xc - R - 0.4 * R_new) } ${0} ${0.5 * (h - Xc - R - 0.4 * R_new)} 0 0`);
            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            if (use_middle_upper){
                container.appendChild(tpl3);
                container.appendChild(tpl4);
                container.appendChild(tpl5);
                container.appendChild(tpl6);
            }
        }
        else {
            tpl3 = tpl.cloneNode(true);
            tpl3.setAttribute("d", `M ${0} ${h} C ${0} ${h- 0.3 * (2 * R + s/30)} ${s/30} ${h- 0.3 * (2 * R + s/30)}  ${s/30} ${h-2 * R + s/30} A ${s/60} ${s/60} 0 0 1 ${0} ${h-2 * R + s /30} A${s/30} ${s/30} 0 0 1 ${2 * s/30} ${h-2 * R + s /30} C${2 * s/30} ${h- 0.3 * (2 * R + s/30)} ${0} ${h- 0.3 * (2 * R + s/30)} ${0} ${h} `);
            

            tpl4 = tpl3.cloneNode(true);
            tpl4.setAttribute("transform", `scale(-1, 1)`);

            tpl3.setAttribute("fill", tertiaryColor);
            tpl4.setAttribute("fill", tertiaryColor);

            if (mainColor === "#b49084") {
                tpl3.setAttribute("fill", "#e8eadd");
                tpl4.setAttribute("fill", "#e8eadd");
            }
            else if (mainColor === "#6ca1d2") {
                tpl3.setAttribute("fill", "#cddae8");
                tpl4.setAttribute("fill", "#cddae8");
            }
            
             



            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("d", `M ${0} ${0} C ${0} ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${h-2 * R - s /30} A${s / 60} ${s / 60} 0 0 0 ${0} ${h-2 * R - s /30} A${s / 30} ${s / 30} 0 0 0 ${2 * s / 30} ${h-2 * R - s /30} C ${2 * s / 30} ${ 0.5 *  (h-2 * R - s /30) } ${0} ${ 0.5 *  (h-2 * R - s /30) }   ${0} ${0}`);
            

            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            if (use_middle_upper){
                container.appendChild(tpl3);
                container.appendChild(tpl4); 
                container.appendChild(tpl5);
                container.appendChild(tpl6); 
            } 
        }

    

}



// Function to create and display the custom context menu
function createContextMenu(event, options) {
  // Prevent the default browser context menu
  event.preventDefault();

  // Remove any existing custom context menu
  const existingMenu = document.getElementById("custom-context-menu");
  if (existingMenu) existingMenu.remove();

  // Create a new menu container
  const menu = document.createElement("div");
  menu.id = "custom-context-menu";
  menu.style.position = "absolute";
  menu.style.top = `${event.clientY}px`;
  menu.style.left = `${event.clientX}px`;
  menu.style.background = "#fff";
  menu.style.border = "1px solid #ccc";
  menu.style.borderRadius = "5px";
  menu.style.padding = "5px 0";
  menu.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";

  console.log("Zukky!");
  // console.log(event.clientX, event.clientY)

  // Populate menu with options
  options.forEach((option) => {
    const menuItem = document.createElement("div");
    menuItem.textContent = option.label;
    menuItem.style.padding = "8px 16px";
    menuItem.style.cursor = "pointer";
    menuItem.style.fontFamily = "Arial, sans-serif";
    menuItem.style.fontSize = "14px";
    menuItem.style.transition = "background 0.2s ease";

    // Hover effect
    menuItem.addEventListener("mouseover", () => {
      menuItem.style.background = "#f0f0f0";
    });
    menuItem.addEventListener("mouseout", () => {
      menuItem.style.background = "transparent";
    });

    // Click handler for menu item
    menuItem.addEventListener("click", () => {
      console.log(option.label + " selected");

        if (option.label === 'Remove'){
          removeSvgChildById(svg, option.id);

        }

      if (option.label === 'Add Square'){
          console.log("Chiho Daisuki!");

          elid = `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;

          if(option.dir === 'Left' && option.neighbor === 'Square'){
            const bcd = new SquareTumpal(option.x - Math.cos(option.rot_deg) * option.l , option.y - Math.sin(option.rot_deg) * option.l , option.l, 'square', option.rot_degree, elid);
            bcd.draw();
          }
          else if(option.dir === 'Down' && option.neighbor === 'Square'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg) * option.l, option.y + Math.cos(option.rot_deg) * option.l, option.l, 'square', option.rot_degree, elid);
            bcd.draw();
          }

          else if(option.dir === 'Up' && option.neighbor === 'Square'){
            const bcd = new SquareTumpal(option.x + Math.sin(option.rot_deg) * option.l, option.y  - Math.cos(option.rot_deg) * option.l , option.l, 'square', option.rot_degree, elid);
            bcd.draw();
          }

          else if(option.dir === 'Right' && option.neighbor === 'Square'){
            const bcd = new SquareTumpal(option.x + Math.cos(option.rot_deg) * option.l , option.y  + Math.sin(option.rot_deg) * option.l , option.l, 'square', option.rot_degree, elid);
            bcd.draw();
          }

          else if(option.dir === 'Down' && option.neighbor === 'Triangle'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg) * (option.l * 0.5 + getheight(option.l)/3), option.y + Math.cos(option.rot_deg) * (option.l * 0.5 + getheight(option.l)/3), option.l, 'square', option.rot_degree, elid);
            bcd.draw();
          }

          else if(option.dir === 'Left' && option.neighbor === 'Triangle'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg - 2 /3 * 2 * Math.PI) * (option.l * 0.5 + getheight(option.l)/3), option.y + Math.cos(option.rot_deg - 2 /3 * 2 * Math.PI) * (option.l * 0.5 + getheight(option.l)/3), option.l, 'square', option.rot_degree - 60, elid);
            bcd.draw();
          }

          else if(option.dir === 'Right' && option.neighbor === 'Triangle'){
            console.log("Chiho channn");
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg + 2 /3 * 2 * Math.PI) * (option.l * 0.5 + getheight(option.l)/3), option.y + Math.cos(option.rot_deg + 2 /3 * 2 * Math.PI) * (option.l * 0.5 + getheight(option.l)/3), option.l, 'square', option.rot_degree + 60, elid);
            bcd.draw();
          }


          else if(option.dir === 'Down' && option.neighbor === 'Hexagon'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg) * (option.l * 0.5 + getheight(option.l)), option.l, 'square', option.rot_degree, elid);
            bcd.draw();
          }
          else if(option.dir === 'Down Left' && option.neighbor === 'Hexagon'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg + Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.l, 'square', option.rot_degree + 60, elid);
            bcd.draw();
          }

          else if(option.dir === 'Up Left' && option.neighbor === 'Hexagon'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg + 2 * Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + 2 * Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.l, 'square', option.rot_degree + 120, elid);
            bcd.draw();
          }

          else if(option.dir === 'Up' && option.neighbor === 'Hexagon'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg + 3 * Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + 3 * Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.l, 'square', option.rot_degree + 180, elid);
            bcd.draw();
          }

          else if(option.dir === 'Up Right' && option.neighbor === 'Hexagon'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg + 4 * Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + 4 * Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.l, 'square', option.rot_degree + 240, elid);
            bcd.draw();
          }

          else if(option.dir === 'Down Right' && option.neighbor === 'Hexagon'){
            const bcd = new SquareTumpal(option.x - Math.sin(option.rot_deg + 5 * Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + 5 * Math.PI / 3) * (option.l * 0.5 + getheight(option.l)), option.l, 'square', option.rot_degree + 300, elid);
            bcd.draw();
          }


      }

      else if (option.label === 'Add Triangle'){
          console.log("Chiho Daisuki!");

          if(option.dir === 'Down' && option.neighbor === 'Triangle' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2) * getheight(option.l) * 2/3 , option.y + Math.sin(option.rot_deg + Math.PI/2) * getheight(option.l) * 2/3, option.l, 'triangle', option.rot_degree + 60, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }
          else if(option.dir === 'Left' && option.neighbor === 'Triangle' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 - 2/3 * 2 * Math.PI) * getheight(option.l) * 2/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 - 2/3 * 2 * Math.PI) * getheight(option.l) * 2/3, option.l, 'triangle', option.rot_degree + 60, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }

          else if(option.dir === 'Right' && option.neighbor === 'Triangle' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 - 2 * 2/3 * 2 * Math.PI) * getheight(option.l) * 2/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 - 2 * 2/3 * 2 * Math.PI) * getheight(option.l) * 2/3, option.l, 'triangle', option.rot_degree + 60, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
            console.log("Chihoooo");
          }

          else if (option.dir === 'Down' && option.neighbor === 'Square' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2) * (option.l * 0.5 + getheight(option.l)/3) , option.y + Math.sin(option.rot_deg + Math.PI/2) * (option.l * 0.5 + getheight(option.l)/3), option.l, 'triangle', option.rot_degree + 60, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }
          else if (option.dir === 'Right' && option.neighbor === 'Square' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 - Math.PI/2) * (option.l * 0.5 + getheight(option.l)/3) , option.y + Math.sin(option.rot_deg + Math.PI/2 - Math.PI/2) * (option.l * 0.5 + getheight(option.l)/3), option.l, 'triangle', option.rot_degree + 60 - 90, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }
          else if (option.dir === 'Up' && option.neighbor === 'Square' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 - 2 * Math.PI/2) * (option.l * 0.5 + getheight(option.l)/3) , option.y + Math.sin(option.rot_deg + Math.PI/2 - 2 *  Math.PI/2) * (option.l * 0.5 + getheight(option.l)/3), option.l, 'triangle', option.rot_degree + 60 - 180, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }
          else if (option.dir === 'Left' && option.neighbor === 'Square' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 - 3 * Math.PI/2) * (option.l * 0.5 + getheight(option.l)/3) , option.y + Math.sin(option.rot_deg + Math.PI/2 - 3 *  Math.PI/2) * (option.l * 0.5 + getheight(option.l)/3), option.l, 'triangle', option.rot_degree + 60 - 270, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }



          else if(option.dir === 'Down' && option.neighbor === 'Hexagon' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2) * getheight(option.l) * 4/3, option.l, 'triangle', option.rot_degree + 60, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }
          else if(option.dir === 'Down Left' && option.neighbor === 'Hexagon' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 + Math.PI/3) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 + Math.PI/3) * getheight(option.l) * 4/3, option.l, 'triangle', option.rot_degree, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }
          else if(option.dir === 'Up Left' && option.neighbor === 'Hexagon' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 + 2 * Math.PI/3) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 2 * Math.PI/3) * getheight(option.l) * 4/3, option.l, 'triangle', option.rot_degree + 60, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }
          else if(option.dir === 'Up' && option.neighbor === 'Hexagon' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 + 3 * Math.PI/3) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 3 * Math.PI/3) * getheight(option.l) * 4/3, option.l, 'triangle', option.rot_degree + 0, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }
          else if(option.dir === 'Up Right' && option.neighbor === 'Hexagon' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 + 4 * Math.PI/3) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 4 * Math.PI/3) * getheight(option.l) * 4/3, option.l, 'triangle', option.rot_degree + 60, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }

          else if(option.dir === 'Down Right' && option.neighbor === 'Hexagon' ){
            const bcd = new TriangleTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 + 5 * Math.PI/3) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 5 * Math.PI/3) * getheight(option.l) * 4/3, option.l, 'triangle', option.rot_degree + 0, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          }

      }


      else if (option.label === 'Add Hexagon'){
                  elid = `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;

          console.log("Chiho Daisuki!");

          if(option.dir === 'Down' && option.neighbor === 'Hexagon' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2) * getheight(option.l) * 2 , option.y + Math.sin(option.rot_deg + Math.PI/2) * getheight(option.l) * 2, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }

          else if(option.dir === 'Down Left' && option.neighbor === 'Hexagon' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2  + Math.PI/3) * getheight(option.l) * 2 , option.y + Math.sin(option.rot_deg + Math.PI/2 + Math.PI/3) * getheight(option.l) * 2, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }

          else if(option.dir === 'Up Left' && option.neighbor === 'Hexagon' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2  + 2 * Math.PI/3) * getheight(option.l) * 2 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 2 * Math.PI/3) * getheight(option.l) * 2, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }

          else if(option.dir === 'Up' && option.neighbor === 'Hexagon' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2  + 3 * Math.PI/3) * getheight(option.l) * 2 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 3 * Math.PI/3) * getheight(option.l) * 2, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }

          else if(option.dir === 'Up Right' && option.neighbor === 'Hexagon' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2  + 4 * Math.PI/3) * getheight(option.l) * 2 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 4 * Math.PI/3) * getheight(option.l) * 2, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }

          else if(option.dir === 'Down Right' && option.neighbor === 'Hexagon' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2  + 5 * Math.PI/3) * getheight(option.l) * 2 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 5 * Math.PI/3) * getheight(option.l) * 2, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }


          else if(option.dir === 'Down' && option.neighbor === 'Triangle' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2) * getheight(option.l) * 4/3, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }

          else if(option.dir === 'Left' && option.neighbor === 'Triangle' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 + 2 * Math.PI/3) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 2 * Math.PI /3) * getheight(option.l) * 4/3, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }
          else if(option.dir === 'Right' && option.neighbor === 'Triangle' ){
            const bcd = new HexagonTumpal(option.x + Math.cos(option.rot_deg + Math.PI/2 + 2 * 2 * Math.PI/3) * getheight(option.l) * 4/3 , option.y + Math.sin(option.rot_deg + Math.PI/2 + 2 * 2 * Math.PI /3) * getheight(option.l) * 4/3, option.l, 'hexagon', option.rot_degree + 60, elid);
            bcd.draw();
          }



          else if(option.dir === 'Left' && option.neighbor === 'Square'){
            const bcd = new HexagonTumpal(option.x - Math.sin(option.rot_deg + Math.PI/2) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + Math.PI /2) * (option.l * 0.5 + getheight(option.l)), option.l, 'hexagon', option.rot_degree, elid);
            bcd.draw();
          }

          else if(option.dir === 'Up' && option.neighbor === 'Square'){
            const bcd = new HexagonTumpal(option.x - Math.sin(option.rot_deg + 2 * Math.PI/2) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + 2 * Math.PI /2) * (option.l * 0.5 + getheight(option.l)), option.l, 'hexagon', option.rot_degree, elid);
            bcd.draw();
          }
          else if(option.dir === 'Right' && option.neighbor === 'Square'){
            const bcd = new HexagonTumpal(option.x - Math.sin(option.rot_deg + 3 * Math.PI/2) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + 3 * Math.PI /2) * (option.l * 0.5 + getheight(option.l)), option.l, 'hexagon', option.rot_degree, elid);
            bcd.draw();
          }
          else if(option.dir === 'Down' && option.neighbor === 'Square'){
            const bcd = new HexagonTumpal(option.x - Math.sin(option.rot_deg + 4 * Math.PI/2) * (option.l * 0.5 + getheight(option.l)), option.y + Math.cos(option.rot_deg + 4 * Math.PI /2) * (option.l * 0.5 + getheight(option.l)), option.l, 'hexagon', option.rot_degree, elid);
            bcd.draw();
          }
          
      }




      menu.remove(); // Remove the menu after an option is clicked
    });

    menu.appendChild(menuItem);
  });

  document.body.appendChild(menu);
  console.log(menu);

// Close the menu if clicking outside
const closeMenu = (e) => {
  if (!menu.contains(e.target)) {
    menu.remove();
    document.removeEventListener("click", closeMenu);
  }
};

// Attach the event listener with a slight delay to avoid immediate removal
setTimeout(() => {
  document.addEventListener("click", closeMenu);
}, 0);


}




  function getRadius(side_length, n){
    theta = (2* Math.PI) / n;
    a = (Math.cos(2 * theta) - Math.cos(theta))** 2;
    b = (Math.sin(2 * theta) - Math.sin(theta))** 2;
    return side_length / Math.sqrt(a + b);
  }


    class SquareTumpal {
        constructor(cx, cy, l, motive, rot_deg = 0, id = 123) {
          this.cx = cx;
          this.cy = cy;
          this.l = l;
          this.motive = motive;
          this.rot_deg = rot_deg * 2 * Math.PI / 360;
          this.rot_degree = rot_deg;
          this.id = id;

        }
          draw() {
            // add function to draw border path
            if (this.motive === 'square'){
                for (let j=0; j<4; j++){
                  drawTumpal(this.cx, this.cy, this.id, this.l, 45, this.rot_degree +  90 * j);
                }
            }
          




    const r_sq = getRadius(this.l , 4);

    let outline1 = document.createElementNS(svgURI, "path");
    // let outline_sentence = `M ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  0 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   0 * Math.PI/2)} 
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  1 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   1 * Math.PI/2)}
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  2 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   2 * Math.PI/2)}
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  3 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   3 * Math.PI/2)}
    //                     Z`;


    let outline_sentence1 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  1 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   1 * Math.PI/2)}
                        L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  2 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   2 * Math.PI/2)}
                        Z`;


    outline1.setAttribute("d", outline_sentence1);
    outline1.setAttribute("fill", "transparent");
    outline1.setAttribute("stroke", "transparent");
    outline1.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline1.setAttribute("pointer-events", "visiblePainted");
    svg.setAttribute("pointer-events", "none");
    outline1.setAttribute("z-index", "10");
    outline1.setAttribute("id", this.id);
    svg.appendChild(outline1);


    let outline2 = document.createElementNS(svgURI, "path");
    let outline_sentence2 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  0 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   0 * Math.PI/2)}
                        L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  1 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   1 * Math.PI/2)}
                        Z`;


    outline2.setAttribute("d", outline_sentence2);
    outline2.setAttribute("fill", "transparent");
    outline2.setAttribute("stroke", "transparent");
    outline2.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline2.setAttribute("pointer-events", "visiblePainted");
    svg.setAttribute("pointer-events", "none");
    outline2.setAttribute("z-index", "10");
        outline2.setAttribute("id", this.id);

    svg.appendChild(outline2);



    let outline3 = document.createElementNS(svgURI, "path");
    let outline_sentence3 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  2 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   2 * Math.PI/2)}
                        L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  3 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   3 * Math.PI/2)}
                        Z`;


    outline3.setAttribute("d", outline_sentence3);
    outline3.setAttribute("fill", "transparent");
    outline3.setAttribute("stroke", "transparent");
    outline3.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline3.setAttribute("pointer-events", "visiblePainted");
    svg.setAttribute("pointer-events", "none");
    outline3.setAttribute("z-index", "10");
    outline3.setAttribute("id", this.id);
    svg.appendChild(outline3);



    let outline4 = document.createElementNS(svgURI, "path");
    let outline_sentence4 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  3 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   3 * Math.PI/2)}
                        L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  4 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   4 * Math.PI/2)}
                        Z`;


    outline4.setAttribute("d", outline_sentence4);
    outline4.setAttribute("fill", "transparent");
    outline4.setAttribute("stroke", "transparent");
    outline4.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline4.setAttribute("pointer-events", "visiblePainted");
    svg.setAttribute("pointer-events", "none");
    outline4.setAttribute("z-index", "10");
    outline4.setAttribute("id", this.id);
    svg.appendChild(outline4);


    // Add event listeners for hover
    outline1.addEventListener("mouseover", () => {
      outline1.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline1.addEventListener("mouseout", () => {
      outline1.setAttribute("stroke", "transparent"); // Reset to original color
    });


    // Add event listeners for hover
    outline2.addEventListener("mouseover", () => {
      outline2.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline2.addEventListener("mouseout", () => {
      outline2.setAttribute("stroke", "transparent"); // Reset to original color
    });


    // Add event listeners for hover
    outline3.addEventListener("mouseover", () => {
      outline3.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline3.addEventListener("mouseout", () => {
      outline3.setAttribute("stroke", "transparent"); // Reset to original color
    });

    // Add event listeners for hover
    outline4.addEventListener("mouseover", () => {
      outline4.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline4.addEventListener("mouseout", () => {
      outline4.setAttribute("stroke", "transparent"); // Reset to original color
    });



// Attach the right-click event (contextmenu) to the outline element
outline1.addEventListener("click", (event) => {
  createContextMenu(event, [
    {
      label: "Add Square",
      x: this.cx,
      y: this.cy,
      l: this.l,
      rot_deg: this.rot_deg,
      rot_degree: this.rot_degree,
      dir: "Left",
      neighbor: "Square"
    },
    {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Left",
          neighbor: "Square"
        },

    {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Left",
          neighbor: "Square"
        },

    {
      label: "Remove",
      id: this.id
    },
  ]);
});

outline2.addEventListener("click", (event) => {
  createContextMenu(event, [
    {
      label: "Add Square",
      x: this.cx,
      y: this.cy,
      l: this.l,
      rot_deg: this.rot_deg,
      rot_degree: this.rot_degree,
      dir: "Down",
      neighbor: "Square"
    },

        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down",
          neighbor: "Square"
        },

    {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down",
          neighbor: "Square"
        },

    {
      label: "Remove",
      id: this.id

    },
  ]);
});

outline3.addEventListener("click", (event) => {
  createContextMenu(event, [
    {
      label: "Add Square",
      x: this.cx,
      y: this.cy,
      l: this.l,
      rot_deg: this.rot_deg,
      rot_degree: this.rot_degree,
      dir: "Up",
      neighbor: "Square"
    },
    {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up",
          neighbor: "Square"
        },

        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up",
          neighbor: "Square"
        },

    {
      label: "Remove",
      id: this.id

    },
  ]);
});


outline4.addEventListener("click", (event) => {
  createContextMenu(event, [
    {
      label: "Add Square",
      x: this.cx,
      y: this.cy,
      l: this.l,
      rot_deg: this.rot_deg,
      rot_degree: this.rot_degree,
      dir: "Right",
      neighbor: "Square"
    },

        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Right",
          neighbor: "Square"
        },

        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Right",
          neighbor: "Square"
        },


    {
      label: "Remove",
      id: this.id

    },
  ]);
});





            }
    }




  class TriangleTumpal {
        constructor(cx, cy, l, motive , rot_deg = 0, id = 123) {
          this.cx = cx;
          this.cy = cy;
          this.l = l;
          this.motive = motive;
          this.rot_deg = rot_deg * 2 * Math.PI / 360;
          this.rot_degree = rot_deg;
          this.id = id;
        }
          draw() {
            if (this.motive === 'triangle') {
                for (let j=0; j<3; j++){
                  drawTumpal(this.cx, this.cy, this.id, this.l, 30, this.rot_degree + 120 * j);
                }
            }

    const r_tri = getRadius(this.l , 3);



    let outline1 = document.createElementNS(svgURI, "path");
    // let outline_sentence = `M ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  0 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   0 * Math.PI/2)} 
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  1 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   1 * Math.PI/2)}
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  2 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   2 * Math.PI/2)}
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  3 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   3 * Math.PI/2)}
    //                     Z`;


    let outline_sentence1 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_tri * Math.cos(this.rot_deg  + Math.PI/6 + 0 * 2 * Math.PI/3)} ${this.cy + r_tri * Math.sin(this.rot_deg + Math.PI/6 +  0 * 2 * Math.PI/3)}
                        L ${this.cx + r_tri * Math.cos(this.rot_deg  + Math.PI/6 + 1 * 2 * Math.PI/3)} ${this.cy + r_tri * Math.sin(this.rot_deg + Math.PI/6 +  1 * 2 * Math.PI/3)}
                        Z`;


    outline1.setAttribute("d", outline_sentence1);
    outline1.setAttribute("fill", "transparent");
    outline1.setAttribute("stroke", "transparent");
    outline1.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline1.setAttribute("pointer-events", "visiblePainted");
    svg.setAttribute("pointer-events", "none");
    outline1.setAttribute("z-index", "10");
    outline1.setAttribute("id", this.id);
    svg.appendChild(outline1);


    // Add event listeners for hover
    outline1.addEventListener("mouseover", () => {
      outline1.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline1.addEventListener("mouseout", () => {
      outline1.setAttribute("stroke", "transparent"); // Reset to original color
    });



    let outline2 = document.createElementNS(svgURI, "path");
    let outline_sentence2 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_tri * Math.cos(this.rot_deg  + Math.PI/6 + 1 * 2 * Math.PI/3)} ${this.cy + r_tri * Math.sin(this.rot_deg + Math.PI/6 +  1 * 2 * Math.PI/3)}
                        L ${this.cx + r_tri * Math.cos(this.rot_deg  + Math.PI/6 + 2 * 2 * Math.PI/3)} ${this.cy + r_tri * Math.sin(this.rot_deg + Math.PI/6 +  2 * 2 * Math.PI/3)}
                        Z`;


    outline2.setAttribute("d", outline_sentence2);
    outline2.setAttribute("fill", "transparent");
    outline2.setAttribute("stroke", "transparent");
    outline2.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline2.setAttribute("pointer-events", "visiblePainted");
    outline2.setAttribute("z-index", "10");
    outline2.setAttribute("id", this.id);

    svg.appendChild(outline2);


    // Add event listeners for hover
    outline2.addEventListener("mouseover", () => {
      outline2.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline2.addEventListener("mouseout", () => {
      outline2.setAttribute("stroke", "transparent"); // Reset to original color
    });


    let outline3 = document.createElementNS(svgURI, "path");
    let outline_sentence3 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_tri * Math.cos(this.rot_deg  + Math.PI/6 + 2 * 2 * Math.PI/3)} ${this.cy + r_tri * Math.sin(this.rot_deg + Math.PI/6 +  2 * 2 * Math.PI/3)}
                        L ${this.cx + r_tri * Math.cos(this.rot_deg  + Math.PI/6 + 3 * 2 * Math.PI/3)} ${this.cy + r_tri * Math.sin(this.rot_deg + Math.PI/6 +  3 * 2 * Math.PI/3)}
                        Z`;


    outline3.setAttribute("d", outline_sentence3);
    outline3.setAttribute("fill", "transparent");
    outline3.setAttribute("stroke", "transparent");
    outline3.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline3.setAttribute("pointer-events", "visiblePainted");
    outline3.setAttribute("z-index", "10");
    outline3.setAttribute("id", this.id);
    svg.appendChild(outline3);


    // Add event listeners for hover
    outline3.addEventListener("mouseover", () => {
      outline3.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline3.addEventListener("mouseout", () => {
      outline3.setAttribute("stroke", "transparent"); // Reset to original color
    });



    outline1.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down",
          neighbor: "Triangle"
        },

        {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down",
          neighbor: "Triangle"

        },
        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down",
          neighbor: "Triangle"
        },


        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });


    outline2.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Left",
          neighbor: "Triangle"
        },
         {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Left",
          neighbor: "Triangle"

        },

        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Left",
          neighbor: "Triangle"

        },

        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });


    outline3.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Right",
          neighbor: "Triangle"
        },
         {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Right",
          neighbor: "Triangle"

        },
        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Right",
          neighbor: "Triangle"

        },
        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });
            }

    }




     class HexagonTumpal {
        constructor(cx, cy, l, motive , rot_deg = 0, id = 123) {
          this.cx = cx;
          this.cy = cy;
          this.l = l;
          this.motive = motive;
          this.rot_deg = rot_deg * 2 * Math.PI / 360;
          this.rot_degree = rot_deg;
          this.id = id;
        }
          draw() {
            if (this.motive === 'hexagon') {
                for (let j=0; j<6; j++){
                  drawTumpal(this.cx, this.cy, this.id, this.l, 60,  60 * j);
                }
            }

    const r_hex = getRadius(this.l , 6);



    let outline1 = document.createElementNS(svgURI, "path");
    // let outline_sentence = `M ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  0 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   0 * Math.PI/2)} 
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  1 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   1 * Math.PI/2)}
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  2 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   2 * Math.PI/2)}
    //                     L ${this.cx + r_sq * Math.cos(this.rot_deg + Math.PI/4 +  3 * Math.PI/2)} ${this.cy + r_sq * Math.sin(this.rot_deg + Math.PI/4 +   3 * Math.PI/2)}
    //                     Z`;


    let outline_sentence1 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 0 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  0   * Math.PI/3)}
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 1 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  1   * Math.PI/3)}
                        Z`;


    outline1.setAttribute("d", outline_sentence1);
    outline1.setAttribute("fill", "transparent");
    outline1.setAttribute("stroke", "transparent");
    outline1.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline1.setAttribute("pointer-events", "visiblePainted");
    svg.setAttribute("pointer-events", "none");
    outline1.setAttribute("z-index", "10");
    outline1.setAttribute("id", this.id);
    svg.appendChild(outline1);


    // Add event listeners for hover
    outline1.addEventListener("mouseover", () => {
      outline1.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline1.addEventListener("mouseout", () => {
      outline1.setAttribute("stroke", "transparent"); // Reset to original color
    });



    let outline2 = document.createElementNS(svgURI, "path");
    let outline_sentence2 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 1 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  1   * Math.PI/3)}
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 2 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  2   * Math.PI/3)}
                        Z`;

    outline2.setAttribute("d", outline_sentence2);
    outline2.setAttribute("fill", "transparent");
    outline2.setAttribute("stroke", "transparent");
    outline2.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline2.setAttribute("pointer-events", "visiblePainted");
    outline2.setAttribute("z-index", "10");
    outline2.setAttribute("id", this.id);
    svg.appendChild(outline2);


    // Add event listeners for hover
    outline2.addEventListener("mouseover", () => {
      outline2.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline2.addEventListener("mouseout", () => {
      outline2.setAttribute("stroke", "transparent"); // Reset to original color
    });


    let outline3 = document.createElementNS(svgURI, "path");
    let outline_sentence3 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 2 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  2   * Math.PI/3)}
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 3 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  3   * Math.PI/3)}
                        Z`;


    outline3.setAttribute("d", outline_sentence3);
    outline3.setAttribute("fill", "transparent");
    outline3.setAttribute("stroke", "transparent");
    outline3.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline3.setAttribute("pointer-events", "visiblePainted");
    outline3.setAttribute("z-index", "10");
    outline3.setAttribute("id", this.id);
    svg.appendChild(outline3);


    // Add event listeners for hover
    outline3.addEventListener("mouseover", () => {
      outline3.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline3.addEventListener("mouseout", () => {
      outline3.setAttribute("stroke", "transparent"); // Reset to original color
    });




    let outline4 = document.createElementNS(svgURI, "path");
    let outline_sentence4 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 3 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  3   * Math.PI/3)}
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 4 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  4   * Math.PI/3)}
                        Z`;


    outline4.setAttribute("d", outline_sentence4);
    outline4.setAttribute("fill", "transparent");
    outline4.setAttribute("stroke", "transparent");
    outline4.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline4.setAttribute("pointer-events", "visiblePainted");
    outline4.setAttribute("z-index", "10");
    outline4.setAttribute("id", this.id);
    svg.appendChild(outline4);


    // Add event listeners for hover
    outline4.addEventListener("mouseover", () => {
      outline4.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline4.addEventListener("mouseout", () => {
      outline4.setAttribute("stroke", "transparent"); // Reset to original color
    });



    let outline5 = document.createElementNS(svgURI, "path");
    let outline_sentence5 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 4 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  4   * Math.PI/3)}
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 5 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  5   * Math.PI/3)}
                        Z`;


    outline5.setAttribute("d", outline_sentence5);
    outline5.setAttribute("fill", "transparent");
    outline5.setAttribute("stroke", "transparent");
    outline5.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline5.setAttribute("pointer-events", "visiblePainted");
    outline5.setAttribute("z-index", "10");
    outline5.setAttribute("id", this.id);
    svg.appendChild(outline5);


    // Add event listeners for hover
    outline5.addEventListener("mouseover", () => {
      outline5.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline5.addEventListener("mouseout", () => {
      outline5.setAttribute("stroke", "transparent"); // Reset to original color
    });




    let outline6 = document.createElementNS(svgURI, "path");
    let outline_sentence6 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 5 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  5   * Math.PI/3)}
                        L ${this.cx + r_hex * Math.cos(this.rot_deg  + Math.PI/3 + 6 *  Math.PI/3)} ${this.cy + r_hex * Math.sin(this.rot_deg + Math.PI/3 +  6   * Math.PI/3)}
                        Z`;


    outline6.setAttribute("d", outline_sentence6);
    outline6.setAttribute("fill", "transparent");
    outline6.setAttribute("stroke", "transparent");
    outline6.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
    outline6.setAttribute("pointer-events", "visiblePainted");
    outline6.setAttribute("z-index", "10");
    outline6.setAttribute("id", this.id);

    svg.appendChild(outline6);


    // Add event listeners for hover
    outline6.addEventListener("mouseover", () => {
      outline6.setAttribute("stroke", "gold"); // Change to hover color
    });


    outline6.addEventListener("mouseout", () => {
      outline6.setAttribute("stroke", "transparent"); // Reset to original color
    });






    outline1.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down",
          neighbor: "Hexagon"
        },

        {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down",
          neighbor: "Hexagon"

        },

        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down",
          neighbor: "Hexagon"
        },


        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });


    outline2.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down Left",
          neighbor: "Hexagon"
        },
        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down Left",
          neighbor: "Hexagon"
        },
         {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down Left",
          neighbor: "Hexagon"

        },
        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });


    outline3.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up Left",
          neighbor: "Hexagon"
        },

        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up Left",
          neighbor: "Hexagon"
        },
         {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up Left",
          neighbor: "Hexagon"

        },
        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });



    outline4.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up",
          neighbor: "Hexagon"
        },

        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up",
          neighbor: "Hexagon"
        },
         {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up",
          neighbor: "Hexagon"

        },
        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });


    outline5.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up Right",
          neighbor: "Hexagon"
        },

        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up Right",
          neighbor: "Hexagon"
        },
         {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Up Right",
          neighbor: "Hexagon"

        },
        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });


    outline6.addEventListener("click", (event) => {
      createContextMenu(event, [
        {
          label: "Add Hexagon",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down Right",
          neighbor: "Hexagon"
        },

        {
          label: "Add Triangle",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down Right",
          neighbor: "Hexagon"
        },
         {
          label: "Add Square",
          x: this.cx,
          y: this.cy,
          l: this.l,
          rot_deg: this.rot_deg,
          rot_degree: this.rot_degree,
          dir: "Down Right",
          neighbor: "Hexagon"

        },
        {
      label: "Remove",
      id: this.id
    
        },
      ]);
    });




            }

    }




      abc = new HexagonTumpal(200, 200, 100, 'hexagon', 0, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
      abc.draw(); 





    // const dialogueBox = document.getElementById("dialogueBox");
    // const svgElement = document.getElementById("clickableRect");


    // // Display the custom menu on right-click
    // svgElement.addEventListener("click", (event) => {
    //   event.preventDefault(); // Prevent default browser context menu

    //   // Show the dialogue box near the cursor position
    //   dialogueBox.style.left = `${event.clientX}px`;
    //   dialogueBox.style.top = `${event.clientY}px`;
    //   dialogueBox.style.display = "block";

    //   event.stopPropagation(); // Prevent closing immediately
    // });

    // // Handle menu option clicks
    // function handleOption(action) {
    //   alert(`You selected: ${action}`);
    //   closeDialogue();
    // }

    // // Close the menu when clicking outside
    // window.addEventListener("click", closeDialogue);

    // function closeDialogue() {
    //   dialogueBox.style.display = "none";
    // }

    // // Close on escape key press
    // window.addEventListener("keydown", (event) => {
    //   if (event.key === "Escape") {
    //     closeDialogue();
    //   }
    // });
  </script>
  <script src="/js/mainUI.js"></script> 
</body>
</html>
