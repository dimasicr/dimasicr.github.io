<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> Batik Tumpal Maker </title>
  <link rel="icon" href="/logo.svg" type="image/svg+xml">
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@200&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/main.css">
</head>
<body>
<div class="container">
    <!-- Toggle button for small screens -->
    <div class="toggle-button" id="toggleButton">
        <img src="/logo.svg" alt="SVG Image Description">
        <span style="margin-left: auto; margin-right: auto;">Geometry of Batik</span>
        <span style="margin-left: auto; margin-right: 20px;">&#9776;</span> 
    </div>
    <!-- Side Navigation Bar -->
    <div class="sidenav" id="sidenav">
        <div style="display: flex; font-size: 24px;">
            <img src="/logo.svg" alt="SVG Image Description">
            <span style="margin-left: 10px;">Geometry of Batik</span>
        </div>
        <script src="/nav.js"></script>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <h1>Batik Tumpal Maker</h1>

        <div class="svg-container" id="svg-container">
            <svg id="svgcontainer" width="400" height="400" viewBox="0 0 400 400"></svg>
        </div>

<select name="PatternType" id="PatternType" class="btns" style="margin-top: 10px;">
    <option value="Sun"  > Sun </option>
    <option value="Moon"> Moon </option>
    <option value="Star" > Star </option>
</select>

            <button id="download-btn">
                <i class="fa fa-download"></i> Download SVG
            </button>
               <article style="width: 80%; text-align: center; margin: auto;">

        <h2 style="text-align: left">How to Use</h2>
        <p>
            You can create a variety of fascinating patterns using our tessellation tool! 
            Simply hover over the side of a polygon and click to add a new motif—voilà, 
            your design expands effortlessly. Don't worry about making mistakes; you can 
            easily remove unwanted patterns using the remove option.
        </p>
        <p>Need some inspiration? Try these ideas:</p>
        <ul>
            <li style="text-align: left">A full design made entirely of hexagons</li>
            <li style="text-align: left">A pattern composed entirely of squares</li>
            <li style="text-align: left">A pattern composed entirely of triangles</li>
            <li style="text-align: left">A creative mix of squares and triangles</li>
        </ul>
               </article>
    </div>
</div>

  <script>
const svgURI = 'http://www.w3.org/2000/svg';
const svg = document.getElementById("svgcontainer");
const screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;

// Color Scheme Options
const themes = {
    "uluwatu": {
        mainColor: "rgb(235, 210, 140)",
        secondaryColor: "rgb(170, 130, 75)",
        strokeColor: "peru",
        strokeWidth: 0.5
    },
    "batavia": {
        mainColor: "#F7F0F5",
        secondaryColor: "#333",
        tertiaryColor: "#F0F7F2",
        strokeColor: "black",
        strokeWidth: 0
    },
    "oldJava": {
        mainColor: "#e4d5b7",
        secondaryColor: "#493118",
        tertiaryColor: "gray",
        strokeColor: "brown",
        strokeWidth: 0.5
    }
    ,"rajaampat": {
        mainColor:   "#F7F0F5",
        secondaryColor: "#5d7591",
        strokeColor: "none",
        strokeWidth: 0.5
    }
    ,"tetradiac": {
        mainColor:   ["#87895d", "#d19f5b", "#945f42", "#616f82"],
        secondaryColor: "#f1e4d8",
        isenColor: "#493118",
        strokeColor: "black",
        strokeWidth: 0.5
    }
    ,"pastel": {
        mainColor: "#b49084",
        secondaryColor: "#38445a",
        isenColor: "#e8eadd",
        strokeColor: "gold",
        strokeWidth: 0.5
    }
    ,"goldenSunset": {
        mainColor: "rgb(214,164,85)",
        secondaryColor: "rgb(105,43,45)",
        tertiaryColor: "rgb(247,235,213)",
        isenColor: "white",
        strokeColor: "rgb(189,53,37)",
        strokeWidth: 0.1
    }   
    ,"green": {
        mainColor: "rgb(83,168,162)",
        secondaryColor: "rgb(0,77,90)",
        tertiaryColor: "rgb(255,253,241)",
        isenColor: "white",
        strokeColor: "rgb(238,134,154)",
        strokeWidth: 0.1
    }  
};


// Helper Function to find the midpoint of two points
function midpoint(x1, x2) {
  return (x1 + x2) / 2;
}

// Function to calculate the angle of a point with respect to the center point
function getClockwiseAngle(p, center) {
    return (Math.atan2(p[1] - center[1], p[0] - center[0]) * 180 / Math.PI + 360) % 360;
}

// Function to get the center point
function getCenterPoint(points) {
    const xSum = points.reduce((acc, p) => acc + p[0], 0);
    const ySum = points.reduce((acc, p) => acc + p[1], 0);
    const totalPoints = points.length;
    return [xSum / totalPoints, ySum / totalPoints];
}

// Function to sort points clockwise
function sortPointsClockwise(points) {
    const center = getCenterPoint(points);
    points.sort((a, b) => getClockwiseAngle(a, center) - getClockwiseAngle(b, center));
    return points;
}

// Setup function
function setup(w, h, mainColor=themes["pastel"].secondaryColor){
    svg.innerHTML = '';
    if (screenWidth > w){
        svg.setAttribute("width", w);
        svg.setAttribute("height", h);
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`); // Ensure correct aspect ratio
        svg.style.width = `${w}px`;
        svg.style.height = `${h}px`;
        console.log("Zukky!!");
      
    }
    else{
        svg.setAttribute("width", screenWidth * (screenWidth/ w));
        svg.setAttribute("height", screenWidth * (screenWidth/w) * h/w);

        svg.setAttribute("viewBox", `0 0 ${screenWidth * (screenWidth/ w)} ${screenWidth * (screenWidth/w) * h/w}`); // Ensure correct aspect ratio
        svg.style.width = `${screenWidth * (screenWidth/ w)}px`;
        svg.style.height = `${screenWidth * (screenWidth/w) * h/w}px`;
    }
    bg_rect = document.createElementNS(svgURI, "rect");
    bg_rect.setAttribute("width", "100%");
    bg_rect.setAttribute("height", "100%");
    bg_rect.setAttribute("fill", mainColor);
    svg.appendChild(bg_rect);
}


if (screenWidth > 900) {
  setup(711, 400);
  console.log("Yamauchi Mizuki!");
}
else {
  setup(400, 400);
}




    function polygonAndStarPaths(n, r, options = {}) {
      if (!Number.isInteger(n) || n < 3) {
        throw new Error("n must be an integer ≥ 3");
      }
      const {
        cx = 0,
        cy = 0,
        rotation = 0,
        k: kInput
      } = options;

      let k = (kInput ?? 2) | 0;
      const kMax = Math.floor((n - 1) / 2);
      if (k < 1) k = 1;
      if (k > kMax) k = kMax;

      const verts = [];

      let balancer = - Math.PI/2 - Math.PI/ (n);
      const base = rotation - balancer;
      for (let i = 0; i < n; i++) {
        const a = base + (2 * Math.PI * i) / n;
        verts.push([cx + r * Math.cos(a), cy + r * Math.sin(a)]);
      }

      const toPath = (points) =>
        `M ${points[0][0]} ${points[0][1]} ` +
        points.slice(1).map(p => `L ${p[0]} ${p[1]}`).join(" ") +
        " Z";

      const polygonPath = toPath(verts);


      return polygonPath;
    }


/**
 * Build SVG path for the outer boundary of a star polygon.
 * - n: number of polygon sides
 * - r: circumradius
 * - options: { cx, cy, rotation, k }
 *
 * Unlike the old version, this one returns ONLY the outer outline
 * (no intersecting diagonals).
 */
function starOutlinePath(n, r, options = {}) {
  if (!Number.isInteger(n) || n < 5) {
    throw new Error("n must be ≥ 5 for a star outline");
  }
  const { cx = 0, cy = 0, rotation = 0, k: kInput } = options;
  let k = (kInput ?? 2) | 0;

  // inner radius calculation (geometry of star polygons)
  // Formula: rin = r * cos(πk/n) / cos(π/n - πk/n)
  const rin = r * Math.cos((Math.PI * k) / n) / Math.cos(Math.PI / n - (Math.PI * k) / n);

  const points = [];
        let balancer = - Math.PI/2 - Math.PI/ (n);

  const base = rotation - balancer;

  for (let i = 0; i < n; i++) {
    // outer vertex
    const aOuter = base + (2 * Math.PI * i) / n;
    points.push([cx + r * Math.cos(aOuter), cy + r * Math.sin(aOuter)]);

    // inner vertex
    const aInner = base + (2 * Math.PI * i) / n + Math.PI / n;
    points.push([cx + rin * Math.cos(aInner), cy + rin * Math.sin(aInner)]);
  }

  // Build path string
  const path = `M ${points[0][0]} ${points[0][1]} ` +
               points.slice(1).map(p => `L ${p[0]} ${p[1]}`).join(" ") +
               " Z";

  return path;
}


/**
 * Calculate the angle between a star polygon valley and its enclosing polygon side.
 *
 * @param {number} n - number of polygon sides (must be >= 5)
 * @param {number} k - step parameter for the star polygon
 * @returns {object} - angles in radians and degrees
 */
function valleySideAngle(n, k) {
  if (!Number.isInteger(n) || n < 5) {
    throw new Error("n must be ≥ 5");
  }
  if (!Number.isInteger(k) || k <= 0 || k >= n/2) {
    throw new Error("k must be an integer in range 1..(n/2 - 1)");
  }

  // Ratio rin/r (inner to outer radius)
  const rinOverR = Math.cos(Math.PI * k / n) /
                   Math.cos(Math.PI / n - Math.PI * k / n);

  // φ = acute angle between enclosing side and valley-to-vertex edge
  const phi = Math.atan(
    (Math.cos(Math.PI / n) - rinOverR) / Math.sin(Math.PI / n)
  );

  // notch angle at the valley (between two star edges)
  const psi = Math.PI - 2 * phi;

  return {
    phiRadians: phi,
    phiDegrees: phi * 180 / Math.PI,
    psiRadians: psi,
    psiDegrees: psi * 180 / Math.PI
  };
}
    



function drawTumpalInner(x, y, id = 123, s = 200, trig_degree = 45, rotDeg= 0, mainColor="#d7c093", secondaryColor="white", strokeColor = "gold", use_outline=false, tertiaryColor = "gold", use_middle_upper=true){  
    let container = document.createElementNS(svgURI, "g");
    container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
    container.setAttribute("stroke-width", 0.1);
    container.setAttribute("id", id);
    svg.appendChild(container);

    const h = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s);
    let outline = document.createElementNS(svgURI, "path");
    outline_sentence = `M0 0  ${0.5 * s} ${h}  ${-0.5 * s} ${h} Z`;
    outline.setAttribute("d", outline_sentence);
    outline.setAttribute("fill", "none");
    outline.setAttribute("stroke", strokeColor);
    if (use_outline){
        container.appendChild(outline);
    }
    if (trig_degree <= 15){
        R = s / 25;
    }
    else if (trig_degree <= 22.5){
        R = s / 20;
    }
    else if (trig_degree <= 45) {
        R = s /15;
    }
    else {
        R = s / 10;
    }

    Xc = 0.5 * s - R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI)
    
    tpl_pth = `M0 ${h}  C ${Xc * 0.5} ${h}  ${Xc * 0.5} ${h - 2*R} ${Xc} ${h - 2* R} A${R} ${R} 0 0 1 ${Xc} ${h} A ${0.5 * R} ${0.5* R} 0 0 1 ${Xc} ${h - R} C${Xc - R} ${h - R} ${Xc - R} ${h}  ${Xc - 2 * R} ${h} Z`;
    tpl = document.createElementNS(svgURI, "path");
    tpl.setAttribute("d", tpl_pth);
    tpl.setAttribute("fill", mainColor);
    tpl.setAttribute("stroke", strokeColor);
    // container.appendChild(tpl);


    tpl2 = tpl.cloneNode(true);
    tpl2.setAttribute("transform", "scale(-1 1)");
    // container.appendChild(tpl2);


    tpl3 = tpl.cloneNode(true);
    tpl3.setAttribute("transform", `rotate(90 0 ${h}) scale(-1 1)`);
    tpl4 = tpl.cloneNode(true);
    tpl4.setAttribute("transform", `rotate(-90 0 ${h})`);

    tpl3.setAttribute("fill", "white");
    tpl4.setAttribute("fill", "white");

    // if (mainColor === "#b49084") {
    //     tpl3.setAttribute("fill", "#e8eadd");
    //     tpl4.setAttribute("fill", "#e8eadd");
    // }

    // else if (mainColor === "#6ca1d2") {
    //     tpl3.setAttribute("fill", "#cddae8");
    //     tpl4.setAttribute("fill", "#cddae8");
    // }
    // else if (mainColor === "#c8c8cf") {
    //     tpl3.setAttribute("fill", "#F7F0F5");
    //     tpl4.setAttribute("fill", "#F7F0F5");
    // }



        if (trig_degree === 60) {
            R_new = 2 * R;
        }
        else if (trig_degree === 45) {
            R_new = R;
        }
        else if (trig_degree === 67.5) {
            R_new = 2.5 * R;
        }
        else if (trig_degree === 75) {
            R_new = 2.5 * R;
        }

        else if (trig_degree === 54) {
            R_new = 1.5  * R;
        }

        else if (trig_degree === 72) {
            R_new = 2.5  * R;
        }
        else if (trig_degree > 60) {
            R_new = 2.5  * R;
        }
        else {
            R_new = R;
        }

        if (trig_degree > 31){
            // container.appendChild(tpl3);
            // container.appendChild(tpl4);
            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("d", `M 0 0 C 0 ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new}  ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new} ${h - Xc - R - 0.4 * R_new} A${0.2 * R_new} ${0.2 * R_new} 0 0 0 ${0} ${h - Xc - R - 0.4 * R_new} A${0.4 * R_new} ${0.4 * R_new} 0 0 0 ${0.8 * R_new} ${ h - Xc - R - 0.4 * R_new} C${0.8 * R_new} ${0.5 * (h - Xc - R - 0.4 * R_new) } ${0} ${0.5 * (h - Xc - R - 0.4 * R_new)} 0 0`);
            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            if (use_middle_upper){
                container.appendChild(tpl3);
                container.appendChild(tpl4);
                container.appendChild(tpl5);
                container.appendChild(tpl6);
            }
        }
        else {
            tpl3 = tpl.cloneNode(true);
            tpl3.setAttribute("d", `M ${0} ${h} C ${0} ${h- 0.3 * (2 * R + s/30)} ${s/30} ${h- 0.3 * (2 * R + s/30)}  ${s/30} ${h-2 * R + s/30} A ${s/60} ${s/60} 0 0 1 ${0} ${h-2 * R + s /30} A${s/30} ${s/30} 0 0 1 ${2 * s/30} ${h-2 * R + s /30} C${2 * s/30} ${h- 0.3 * (2 * R + s/30)} ${0} ${h- 0.3 * (2 * R + s/30)} ${0} ${h} `);
            

            tpl4 = tpl3.cloneNode(true);
            tpl4.setAttribute("transform", `scale(-1, 1)`);

            tpl3.setAttribute("fill", "white");
            tpl4.setAttribute("fill", "white");

            // if (mainColor === "#b49084") {
            //     tpl3.setAttribute("fill", "#e8eadd");
            //     tpl4.setAttribute("fill", "#e8eadd");
            // }
            // else if (mainColor === "#6ca1d2") {
            //     tpl3.setAttribute("fill", "#cddae8");
            //     tpl4.setAttribute("fill", "#cddae8");
            // }
            
             



            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("d", `M ${0} ${0} C ${0} ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${h-2 * R - s /30} A${s / 60} ${s / 60} 0 0 0 ${0} ${h-2 * R - s /30} A${s / 30} ${s / 30} 0 0 0 ${2 * s / 30} ${h-2 * R - s /30} C ${2 * s / 30} ${ 0.5 *  (h-2 * R - s /30) } ${0} ${ 0.5 *  (h-2 * R - s /30) }   ${0} ${0}`);
            

            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            if (use_middle_upper){
                container.appendChild(tpl3);
                container.appendChild(tpl4); 
                container.appendChild(tpl5);
                container.appendChild(tpl6); 
            } 
        }

    

}



function drawTumpalStar(x, y, id = 123, s = 200, trig_degree = 45, rotDeg= 0, mainColor="#d7c093", secondaryColor="white", strokeColor = "gold", use_outline=false, tertiaryColor = "gold", use_middle_upper=true){  
    let container = document.createElementNS(svgURI, "g");
    container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
    container.setAttribute("stroke-width", 0.1);
    container.setAttribute("id", id);
    svg.appendChild(container);

    const h = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s);
    let outline = document.createElementNS(svgURI, "path");
    outline_sentence = `M0 0  ${0.5 * s} ${h}  ${-0.5 * s} ${h} Z`;
    outline.setAttribute("d", outline_sentence);
    outline.setAttribute("fill", "none");
    outline.setAttribute("stroke", strokeColor);
    if (use_outline){
        container.appendChild(outline);
    }
    if (trig_degree <= 15){
        R = s / 25;
    }
    else if (trig_degree <= 22.5){
        R = s / 20;
    }
    else if (trig_degree <= 45) {
        R = s /15;
    }
    else {
        R = s / 10;
    }

    Xc = 0.5 * s - R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI)
    
    tpl_pth = `M0 ${h}  C ${Xc * 0.5} ${h}  ${Xc * 0.5} ${h - 2*R} ${Xc} ${h - 2* R} A${R} ${R} 0 0 1 ${Xc} ${h} A ${0.5 * R} ${0.5* R} 0 0 1 ${Xc} ${h - R} C${Xc - R} ${h - R} ${Xc - R} ${h}  ${Xc - 2 * R} ${h} Z`;
    tpl = document.createElementNS(svgURI, "path");
    tpl.setAttribute("d", tpl_pth);
    tpl.setAttribute("fill", mainColor);
    tpl.setAttribute("stroke", strokeColor);
    container.appendChild(tpl);


    tpl2 = tpl.cloneNode(true);
    tpl2.setAttribute("transform", "scale(-1 1)");
    container.appendChild(tpl2);


    tpl3 = tpl.cloneNode(true);
    tpl3.setAttribute("transform", `rotate(90 0 ${h}) scale(-1 1)`);
    tpl4 = tpl.cloneNode(true);
    tpl4.setAttribute("transform", `rotate(-90 0 ${h})`);

    tpl3.setAttribute("fill", "white");
    tpl4.setAttribute("fill", "white");

    // if (mainColor === "#b49084") {
    //     tpl3.setAttribute("fill", "#e8eadd");
    //     tpl4.setAttribute("fill", "#e8eadd");
    // }

    // else if (mainColor === "#6ca1d2") {
    //     tpl3.setAttribute("fill", "#cddae8");
    //     tpl4.setAttribute("fill", "#cddae8");
    // }
    // else if (mainColor === "#c8c8cf") {
    //     tpl3.setAttribute("fill", "#F7F0F5");
    //     tpl4.setAttribute("fill", "#F7F0F5");
    // }



        if (trig_degree === 60) {
            R_new = 2 * R;
        }
        else if (trig_degree === 45) {
            R_new = R;
        }
        else if (trig_degree === 67.5) {
            R_new = 2.5 * R;
        }
        else if (trig_degree === 75) {
            R_new = 2.5 * R;
        }

        else if (trig_degree === 54) {
            R_new = 1.5  * R;
        }
        else if (trig_degree === 36) {
            R_new = 1.5  * R;
        }
        else if (trig_degree === 72) {
            R_new = 2.5  * R;
        }
        else if (trig_degree > 60) {
            R_new = 2.5  * R;
        }
        else {
            R_new = R;
        }

        if (trig_degree > 36){
            // container.appendChild(tpl3);
            // container.appendChild(tpl4);
            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("d", `M 0 0 C 0 ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new}  ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new} ${h - Xc - R - 0.4 * R_new} A${0.2 * R_new} ${0.2 * R_new} 0 0 0 ${0} ${h - Xc - R - 0.4 * R_new} A${0.4 * R_new} ${0.4 * R_new} 0 0 0 ${0.8 * R_new} ${ h - Xc - R - 0.4 * R_new} C${0.8 * R_new} ${0.5 * (h - Xc - R - 0.4 * R_new) } ${0} ${0.5 * (h - Xc - R - 0.4 * R_new)} 0 0`);
            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            if (use_middle_upper){
                container.appendChild(tpl3);
                container.appendChild(tpl4);
                container.appendChild(tpl5);
                container.appendChild(tpl6);
            }
        }
        else {
            tpl3 = tpl.cloneNode(true);
            tpl3.setAttribute("d", `M ${0} ${h} C ${0} ${h- 0.3 * (2 * R + s/30)} ${s/30} ${h- 0.3 * (2 * R + s/30)}  ${s/30} ${h-2 * R + s/30} A ${s/60} ${s/60} 0 0 1 ${0} ${h-2 * R + s /30} A${s/30} ${s/30} 0 0 1 ${2 * s/30} ${h-2 * R + s /30} C${2 * s/30} ${h- 0.3 * (2 * R + s/30)} ${0} ${h- 0.3 * (2 * R + s/30)} ${0} ${h} `);
            

            tpl4 = tpl3.cloneNode(true);
            tpl4.setAttribute("transform", `scale(-1, 1)`);

            tpl3.setAttribute("fill", "white");
            tpl4.setAttribute("fill", "white");

            // if (mainColor === "#b49084") {
            //     tpl3.setAttribute("fill", "#e8eadd");
            //     tpl4.setAttribute("fill", "#e8eadd");
            // }
            // else if (mainColor === "#6ca1d2") {
            //     tpl3.setAttribute("fill", "#cddae8");
            //     tpl4.setAttribute("fill", "#cddae8");
            // }
            
             



            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("d", `M ${0} ${0} C ${0} ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${h-2 * R - s /30} A${s / 60} ${s / 60} 0 0 0 ${0} ${h-2 * R - s /30} A${s / 30} ${s / 30} 0 0 0 ${2 * s / 30} ${h-2 * R - s /30} C ${2 * s / 30} ${ 0.5 *  (h-2 * R - s /30) } ${0} ${ 0.5 *  (h-2 * R - s /30) }   ${0} ${0}`);
            

            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            if (use_middle_upper){
                container.appendChild(tpl3);
                container.appendChild(tpl4); 
                container.appendChild(tpl5);
                container.appendChild(tpl6); 
            } 
        }

    

}

function removeSvgChildById(svgContainer, targetId) {
  // Get all child elements
  const children = svgContainer.children;

  // Loop through children in reverse and remove the ones with the matching ID
  for (let i = children.length - 1; i >= 0; i--) {
    if (children[i].getAttribute("id") === targetId) {
      svgContainer.removeChild(children[i]);
    }
  }
}

function removeTransparentSVGElements(svgElement) {
  // Find all child elements of the SVG (path, circle, rect, etc.)
  const childElements = svgElement.querySelectorAll("*");

  childElements.forEach((element) => {
    const fill = element.getAttribute("fill");

    // Check if the fill is 'transparent' or an equivalent value
    if (fill === "transparent" || (fill === null && window.getComputedStyle(element).fill === "rgba(0, 0, 0, 0)")) {
      // If fill is transparent, remove the element
      element.remove();
    }
  });
}


  function getheight(wp){
     return Math.sin(60 * 2 * Math.PI/ 360) * wp;
  }


function drawTumpal(x, y, id = 123, s = 200, trig_degree = 45, rotDeg= 0, mainColor="#b49084", secondaryColor="#38445a", strokeColor = "gold", use_outline=false, tertiaryColor = "gold", use_middle_upper=true){  
    let container = document.createElementNS(svgURI, "g");
    container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
    container.setAttribute("stroke-width", 0.1);
    container.setAttribute("id", id);
    svg.appendChild(container);

    const h = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s);
    let outline = document.createElementNS(svgURI, "path");
    outline_sentence = `M0 0  ${0.5 * s} ${h}  ${-0.5 * s} ${h} Z`;
    outline.setAttribute("d", outline_sentence);
    outline.setAttribute("fill", "none");
    outline.setAttribute("stroke", strokeColor);
    if (use_outline){
        container.appendChild(outline);
    }
    if (trig_degree === 30) {
        R = s /15;
    }
    else if (trig_degree === 18){
        R = s / 20;
    }
    else if (trig_degree === 15){
        R = s / 25;
    }
    else if (trig_degree === 22.5){
        R = s / 20;
    }
    else {
        R = s / 10;
    }

    Xc = 0.5 * s - R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI)
    
    tpl_pth = `M0 ${h}  C ${Xc * 0.5} ${h}  ${Xc * 0.5} ${h - 2*R} ${Xc} ${h - 2* R} A${R} ${R} 0 0 1 ${Xc} ${h} A ${0.5 * R} ${0.5* R} 0 0 1 ${Xc} ${h - R} C${Xc - R} ${h - R} ${Xc - R} ${h}  ${Xc - 2 * R} ${h} Z`;
    tpl = document.createElementNS(svgURI, "path");
    tpl.setAttribute("d", tpl_pth);
    tpl.setAttribute("fill", mainColor);
    tpl.setAttribute("stroke", strokeColor);
    container.appendChild(tpl);


    tpl2 = tpl.cloneNode(true);
    tpl2.setAttribute("transform", "scale(-1 1)");
    container.appendChild(tpl2);


    tpl3 = tpl.cloneNode(true);
    tpl3.setAttribute("transform", `rotate(90 0 ${h}) scale(-1 1)`);
    tpl4 = tpl.cloneNode(true);
    tpl4.setAttribute("transform", `rotate(-90 0 ${h})`);

    tpl3.setAttribute("fill", tertiaryColor);
    tpl4.setAttribute("fill", tertiaryColor);

    if (mainColor === "#b49084") {
        tpl3.setAttribute("fill", "#e8eadd");
        tpl4.setAttribute("fill", "#e8eadd");
    }

    else if (mainColor === "#6ca1d2") {
        tpl3.setAttribute("fill", "#cddae8");
        tpl4.setAttribute("fill", "#cddae8");
    }
    else if (mainColor === "#c8c8cf") {
        tpl3.setAttribute("fill", "#F7F0F5");
        tpl4.setAttribute("fill", "#F7F0F5");
    }



        if (trig_degree === 60) {
            R_new = 2 * R;
        }
        else if (trig_degree === 45) {
            R_new = R;
        }
        else if (trig_degree === 67.5) {
            R_new = 2.5 * R;
        }
        else if (trig_degree === 75) {
            R_new = 2.5 * R;
        }

        else if (trig_degree >= 54 && trig_degree < 70) {
            R_new = 1.5  * R;
        }

        else if (trig_degree >= 70) {
            R_new = 2.5  * R;
        }

        else {
            R_new = R;
        }

        if (trig_degree !== 30 && trig_degree !== 18 && trig_degree !== 22.5 && trig_degree !== 15){
            // container.appendChild(tpl3);
            // container.appendChild(tpl4);
            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("d", `M 0 0 C 0 ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new}  ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new} ${h - Xc - R - 0.4 * R_new} A${0.2 * R_new} ${0.2 * R_new} 0 0 0 ${0} ${h - Xc - R - 0.4 * R_new} A${0.4 * R_new} ${0.4 * R_new} 0 0 0 ${0.8 * R_new} ${ h - Xc - R - 0.4 * R_new} C${0.8 * R_new} ${0.5 * (h - Xc - R - 0.4 * R_new) } ${0} ${0.5 * (h - Xc - R - 0.4 * R_new)} 0 0`);
            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            if (use_middle_upper){
                container.appendChild(tpl3);
                container.appendChild(tpl4);
                container.appendChild(tpl5);
                container.appendChild(tpl6);
            }
        }
        else {
            tpl3 = tpl.cloneNode(true);
            tpl3.setAttribute("d", `M ${0} ${h} C ${0} ${h- 0.3 * (2 * R + s/30)} ${s/30} ${h- 0.3 * (2 * R + s/30)}  ${s/30} ${h-2 * R + s/30} A ${s/60} ${s/60} 0 0 1 ${0} ${h-2 * R + s /30} A${s/30} ${s/30} 0 0 1 ${2 * s/30} ${h-2 * R + s /30} C${2 * s/30} ${h- 0.3 * (2 * R + s/30)} ${0} ${h- 0.3 * (2 * R + s/30)} ${0} ${h} `);
            

            tpl4 = tpl3.cloneNode(true);
            tpl4.setAttribute("transform", `scale(-1, 1)`);

            tpl3.setAttribute("fill", tertiaryColor);
            tpl4.setAttribute("fill", tertiaryColor);

            if (mainColor === "#b49084") {
                tpl3.setAttribute("fill", "#e8eadd");
                tpl4.setAttribute("fill", "#e8eadd");
            }
            else if (mainColor === "#6ca1d2") {
                tpl3.setAttribute("fill", "#cddae8");
                tpl4.setAttribute("fill", "#cddae8");
            }
            
             



            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("d", `M ${0} ${0} C ${0} ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${h-2 * R - s /30} A${s / 60} ${s / 60} 0 0 0 ${0} ${h-2 * R - s /30} A${s / 30} ${s / 30} 0 0 0 ${2 * s / 30} ${h-2 * R - s /30} C ${2 * s / 30} ${ 0.5 *  (h-2 * R - s /30) } ${0} ${ 0.5 *  (h-2 * R - s /30) }   ${0} ${0}`);
            

            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            if (use_middle_upper){
                container.appendChild(tpl3);
                container.appendChild(tpl4); 
                container.appendChild(tpl5);
                container.appendChild(tpl6); 
            } 
        }

    

}



function drawAlternateTumpal(x, y, id = 123, s = 200, trig_degree = 45, rotDeg= 0, mainColor="#b49084", secondaryColor="#38445a", strokeColor = "gold", use_outline=false, tertiaryColor = themes["goldenSunset"].tertiaryColor, use_middle_upper=true){  





    let container = document.createElementNS(svgURI, "g");
    container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
    container.setAttribute("stroke-width", 0.3);
    container.setAttribute("id", id);

    svg.appendChild(container);
    const h = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s);
    let outline = document.createElementNS(svgURI, "path");
    outline_sentence = `M0 0  ${0.5 * s} ${h}  ${-0.5 * s} ${h} Z`;
    outline.setAttribute("d", outline_sentence);
    outline.setAttribute("fill", "none");
    outline.setAttribute("stroke", strokeColor);









    if (use_outline){
        container.appendChild(outline);
    }
    if (trig_degree === 30) {
        R = s /14.5;
    }
    else if (trig_degree === 18){
        R = s / 20;
    }
    else if (trig_degree === 15){
        R = s / 25;
    }
    else if (trig_degree === 22.5){
        R = s / 25;
    }

    else if (trig_degree === 45){
        R = s / 12;
    }
    else {
        R = s / 10;
    }

    Xc = 0.5 * s - R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI);

    if (trig_degree === 22.5){
        tpl_pth = `M0 ${h- 2 * R}  C ${Xc * 0.5} ${h - 2 * R}  ${Xc * 0.5} ${h} ${Xc} ${h} A${R} ${R} 0 0 0 ${Xc} ${h - 2 * R} A ${0.5 * R} ${0.5* R} 0 0 0 ${Xc} ${h - R} C${Xc  * 0.5} ${h - R} ${Xc  * 0.5 } ${h -2 * R}  ${Xc  * 0.2} ${h - 2 * R} Z`;
    }
    else {
        tpl_pth = `M0 ${h- 2 * R}  C ${Xc * 0.5} ${h - 2 * R}  ${Xc * 0.5} ${h} ${Xc} ${h} A${R} ${R} 0 0 0 ${Xc} ${h - 2 * R} A ${0.5 * R} ${0.5* R} 0 0 0 ${Xc} ${h - R} C${Xc - R} ${h - R} ${Xc - R} ${h -2 * R}  ${Xc - 2 * R} ${h - 2 * R} Z`;
    }

    tpl = document.createElementNS(svgURI, "path");
    tpl.setAttribute("d", tpl_pth);
    tpl.setAttribute("fill", mainColor);
    tpl.setAttribute("stroke", "none");
    container.appendChild(tpl);


    kulitRadius = R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI);
    kx = Math.cos(trig_degree/360 * 2 * Math.PI) * kulitRadius;
    ky = Math.sin(trig_degree/360 * 2 * Math.PI) * kulitRadius;


    // let kulit = document.createElementNS(svgURI, "path");
    // kulit_sentence = `M0 ${h- 2 * R}  C ${Xc * 0.5} ${h - 2 * R}  ${Xc * 0.5} ${h} ${Xc} ${h} A${R} ${R} 0 0 0 ${0.5 * s - kx} ${h - ky} 
    //                    A${R} ${R} 0 0 0 ${h} ${Xc}  C ${h} ${Xc * 0.5} ${h - 2 * R} ${ Xc * 0.5} ${h- 2 * R} ${0}


    //   `;;
    // kulit.setAttribute("d", kulit_sentence);
    // kulit.setAttribute("fill", secondaryColor);
    // kulit.setAttribute("stroke", "none");
    // container.appendChild(kulit)




    tpl2 = tpl.cloneNode(true);
    tpl2.setAttribute("transform", "scale(-1 1)");
    container.appendChild(tpl2);

    const h_small = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s) - 2 * R;
    const s_small = 2 * h_small / Math.tan(trig_degree/360 * 2 * Math.PI) ;

    if (trig_degree === 30) {
        R_small =  0.5 * R;
    }
    else {
        R_small = 0.75 * R
    }
    Xc_small = 0.5 * s_small - R_small / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI);


    if (trig_degree === 22.5){
        tpl_pth = `M0 ${h_small}  C ${Xc_small * 0.5} ${h_small}  ${Xc_small * 0.5} ${h_small - 2*R_small} ${Xc_small } ${h_small - 2* R_small} A${R_small} ${R_small} 0 0 1 ${Xc_small} ${h_small} A ${0.5 * R_small} ${0.5* R_small} 0 0 1 ${Xc_small} ${h_small - R_small} C${Xc_small * 0.5} ${h_small - R_small} ${Xc_small  * 0.5} ${h_small}  ${Xc_small * 0.2} ${h_small} Z`;
    }

    else {
        tpl_pth = `M0 ${h_small}  C ${Xc_small * 0.5} ${h_small}  ${Xc_small * 0.5} ${h_small - 2*R_small} ${Xc_small } ${h_small - 2* R_small} A${R_small} ${R_small} 0 0 1 ${Xc_small} ${h_small} A ${0.5 * R_small} ${0.5* R_small} 0 0 1 ${Xc_small} ${h_small - R_small} C${Xc_small - R_small} ${h_small - R_small} ${Xc_small - R_small} ${h_small}  ${Xc_small - 2 * R_small} ${h_small} Z`;
    }
    tpl3 = document.createElementNS(svgURI, "path");
    tpl3.setAttribute("d", tpl_pth);
    tpl3.setAttribute("fill", mainColor);
    tpl3.setAttribute("stroke", "none");
    container.appendChild(tpl3);

    tpl4 = tpl3.cloneNode(true);
    tpl4.setAttribute("transform", "scale(-1 1)");
    container.appendChild(tpl4);


    circle = document.createElementNS(svgURI, "ellipse");
    circle.setAttribute("cx", 0.45 * s); // x-coordinate of the center
    circle.setAttribute("cy", 1 * h ); // y-coordinate of the center
    circle.setAttribute("rx", 0.015 * s);   // radius
        circle.setAttribute("ry", 0.015 * s);   // radius

    circle.setAttribute("fill", strokeColor); // fill color
    container.appendChild(circle);

    circle = document.createElementNS(svgURI, "circle");
    circle.setAttribute("cx", -0.075 * s); // x-coordinate of the center
    circle.setAttribute("cy", 0.9 * h ); // y-coordinate of the center
    circle.setAttribute("r", 0.02 * s);   // radius
    circle.setAttribute("fill", strokeColor); // fill color
    // container.appendChild(circle);


        if (trig_degree === 60) {
            R_new = 2 * R;
        }

        else if (trig_degree === 30) {
            R_new = 0.5 * R;
        }
        else if (trig_degree === 45) {
            R_new = 1.5 * R;
        }
        else if (trig_degree === 67.5) {
            R_new = 2.5 * R;
        }
        else if (trig_degree === 75) {
            R_new = 2.5 * R;
        }

        else if (trig_degree === 54) {
            R_new = 1.5  * R;
        }

        else if (trig_degree === 72) {
            R_new = 2.5  * R;
        }

        else {
            R_new = R;
        }

        if (trig_degree === 45 ){
            // container.appendChild(tpl3);
            // container.appendChild(tpl4);
            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("fill", tertiaryColor);
            tpl5.setAttribute("d", `M 0 0 C 0 ${ 0.5 * (h - Xc - 0.4 * R_new) } ${0.4 * R_new}  ${ 0.5 * (h - Xc - 0.4 * R_new) } ${0.4 * R_new} ${h - Xc - 0.4 * R_new} A${0.2 * R_new} ${0.2 * R_new} 0 0 0 ${0} ${h - Xc - 0.4 * R_new} A${0.4 * R_new} ${0.4 * R_new} 0 0 0 ${0.8 * R_new} ${ h - Xc  - 0.4 * R_new} C${0.8 * R_new} ${0.5 * (h - Xc - 0.4 * R_new) } ${0} ${0.5 * (h - Xc - 0.4 * R_new)} 0 0`);
            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);


                container.appendChild(tpl5);
                container.appendChild(tpl6);
        }



        else if (trig_degree !== 30 && trig_degree !== 18 && trig_degree !== 22.5 && trig_degree !== 15 ){
            // container.appendChild(tpl3);
            // container.appendChild(tpl4);
            tpl5 = tpl.cloneNode(true);
            tpl5.setAttribute("fill", tertiaryColor);
            tpl5.setAttribute("d", `M 0 0 C 0 ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new}  ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new} ${h - Xc - R - 0.4 * R_new} A${0.2 * R_new} ${0.2 * R_new} 0 0 0 ${0} ${h - Xc - R - 0.4 * R_new} A${0.4 * R_new} ${0.4 * R_new} 0 0 0 ${0.8 * R_new} ${ h - Xc - R - 0.4 * R_new} C${0.8 * R_new} ${0.5 * (h - Xc - R - 0.4 * R_new) } ${0} ${0.5 * (h - Xc - R - 0.4 * R_new)} 0 0`);
            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);


                container.appendChild(tpl5);
                container.appendChild(tpl6);
        }
        else {
            // tpl3 = tpl.cloneNode(true);
            // tpl3.setAttribute("d", `M ${0} ${h} C ${0} ${h- 0.3 * (2 * R + s/30)} ${s/30} ${h- 0.3 * (2 * R + s/30)}  ${s/30} ${h-2 * R + s/30} A ${s/60} ${s/60} 0 0 1 ${0} ${h-2 * R + s /30} A${s/30} ${s/30} 0 0 1 ${2 * s/30} ${h-2 * R + s /30} C${2 * s/30} ${h- 0.3 * (2 * R + s/30)} ${0} ${h- 0.3 * (2 * R + s/30)} ${0} ${h} `);
            

            // tpl4 = tpl3.cloneNode(true);
            // tpl4.setAttribute("transform", `scale(-1, 1)`);

            // tpl3.setAttribute("fill", tertiaryColor);
            // tpl4.setAttribute("fill", tertiaryColor);

            // if (mainColor === "#b49084") {
            //     tpl3.setAttribute("fill", "#e8eadd");
            //     tpl4.setAttribute("fill", "#e8eadd");
            // }
            // else if (mainColor === "#6ca1d2") {
            //     tpl3.setAttribute("fill", "#cddae8");
            //     tpl4.setAttribute("fill", "#cddae8");
            // }
            
             
            // console.log("Chiho!");

            if (trig_degree === 30){
                R = R * 1.25;
            }


            tpl5 = tpl.cloneNode(true);


            if (trig_degree === 30){
                tpl5.setAttribute("d", `M ${0} ${0} C ${0} ${0. *  (h-2 * R - s /30) }  ${s/30}  ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${h-2 * R - s /30} A${s / 60} ${s / 60} 0 0 0 ${0} ${h-2 * R - s /30} A${s / 30} ${s / 30} 0 0 0 ${2 * s / 30} ${h-2 * R - s /30} C ${2 * s / 30} ${ 0.5 *  (h-2 * R - s /30) } ${0} ${ 0.5 *  (h-3 * R - s /30) }   ${0} ${0}`);

            }

            else if (trig_degree === 22.5) {
                tpl5.setAttribute("d", `M ${0} ${0} C ${0} ${0. *  (h-2 * R - s /20) }  ${s/30}  ${0.5 *  (h-2 * R - s /20) }  ${s/30}  ${h-2 * R - s /20} A${s / 60} ${s / 60} 0 0 0 ${0} ${h-2 * R - s /20} A${s / 30} ${s / 30} 0 0 0 ${2 * s / 30} ${h-2 * R - s /20} C ${2 * s / 30} ${ 0.5 *  (h-2 * R - s /20) } ${0} ${ 0.5 *  (h-2 * R - s /10) }   ${0} ${0}`);
            }
            else {
                tpl5.setAttribute("d", `M ${0} ${0} C ${0} ${0. *  (h-2 * R - s /30) }  ${s/30}  ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${h-2 * R - s /30} A${s / 60} ${s / 60} 0 0 0 ${0} ${h-2 * R - s /30} A${s / 30} ${s / 30} 0 0 0 ${2 * s / 30} ${h-2 * R - s /30} C ${2 * s / 30} ${ 0.5 *  (h-2 * R - s /30) } ${0} ${ 0.5 *  (h-2 * R - s /30) }   ${0} ${0}`);
            }

            tpl5.setAttribute("fill", tertiaryColor);


            tpl6 = tpl5.cloneNode(true);
            tpl6.setAttribute("transform", `scale(-1, 1)`);

            // if (use_middle_upper){
            //     container.appendChild(tpl3);
            //     container.appendChild(tpl4); 
                container.appendChild(tpl5);
                container.appendChild(tpl6); 
            // } 
        }

    



}





// Function to create and display the custom context menu
function createContextMenu(event, options) {
  event.preventDefault();

  // Remove any existing context menu
  const existingMenu = document.getElementById("custom-context-menu");
  if (existingMenu) existingMenu.remove();

  // Create the main menu container
  const menu = document.createElement("div");
  menu.id = "custom-context-menu";
  menu.style.position = "absolute";
  menu.style.top = `${event.clientY}px`;
  menu.style.left = `${event.clientX}px`;
  menu.style.background = "#fff";
  menu.style.border = "1px solid #ccc";
  menu.style.borderRadius = "5px";
  menu.style.padding = "5px 0";
  menu.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
  menu.style.minWidth = "160px";

  // Populate menu with options
  options.forEach((option) => {
    const menuItem = document.createElement("div");
    menuItem.style.display = "flex";
    menuItem.style.justifyContent = "space-between";
    menuItem.style.alignItems = "center";
    menuItem.style.padding = "8px 16px";
    menuItem.style.cursor = "pointer";
    menuItem.style.fontFamily = "Arial, sans-serif";
    menuItem.style.fontSize = "14px";
    menuItem.style.transition = "background 0.2s ease";
    menuItem.style.position = "relative";

    const labelSpan = document.createElement("span");
    labelSpan.textContent = option.label;
    menuItem.appendChild(labelSpan);

    // Hover effect
    menuItem.addEventListener("mouseover", () => (menuItem.style.background = "#f0f0f0"));
    menuItem.addEventListener("mouseout", () => (menuItem.style.background = "transparent"));

    // **Check if this menu item has a submenu**
    if (option.submenu && option.submenu.length > 0) {
      // Add arrow indicator with spacing
      const arrow = document.createElement("span");
      arrow.textContent = "▶";
      arrow.style.marginLeft = "auto";
      arrow.style.paddingLeft = "10px"; // More space between text and arrow
      menuItem.appendChild(arrow);

      // Create a submenu container
      const submenu = document.createElement("div");
      submenu.style.position = "absolute";
      submenu.style.top = "0";
      submenu.style.left = "100%";
      submenu.style.background = "#fff";
      submenu.style.border = "1px solid #ccc";
      submenu.style.borderRadius = "5px";
      submenu.style.padding = "5px 0";
      submenu.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
      submenu.style.display = "none"; // Initially hidden
      submenu.style.minWidth = "160px";

      // Populate the submenu
      option.submenu.forEach((subOption) => {
        const subItem = document.createElement("div");
        subItem.textContent = subOption.label;
        subItem.style.padding = "8px 16px";
        subItem.style.cursor = "pointer";
        subItem.style.transition = "background 0.2s ease";
        
        subItem.addEventListener("mouseover", () => (subItem.style.background = "#f0f0f0"));
        subItem.addEventListener("mouseout", () => (subItem.style.background = "transparent"));
        
        // Submenu item click event
        subItem.addEventListener("click", () => {
          console.log(subOption.label + " selected");
          if (subOption.action) subOption.action();

      if (subOption.label === 'Add Pentagon'){
          elid = `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;
            const bcd = new PolygonTumpal(subOption.x + Math.cos(subOption.directionDegrees ) * (Math.tan(subOption.isoscelesAngle * Math.PI/180) * 0.5 * subOption.l + Math.tan(54 * Math.PI/180) * 0.5 * subOption.l )
                        , subOption.y + Math.sin(subOption.directionDegrees ) * (Math.tan(subOption.isoscelesAngle * Math.PI/180) * 0.5 * subOption.l + Math.tan(54 * Math.PI/180) * 0.5 * subOption.l)
                        , subOption.l
                        , 5
                        , -54 + subOption.directionDegrees * 180 / Math.PI
                        , `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();

      }


     else if (subOption.label === 'Add Octagon'){
                  elid = `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;

            const bcd = new PolygonTumpal(subOption.x + Math.cos(subOption.directionDegrees ) * (Math.tan(subOption.isoscelesAngle * Math.PI/180) * 0.5 * subOption.l + Math.tan(67.5 * Math.PI/180) * 0.5 * subOption.l )
                        , subOption.y + Math.sin(subOption.directionDegrees ) * (Math.tan(subOption.isoscelesAngle * Math.PI/180) * 0.5 * subOption.l + Math.tan(67.5 * Math.PI/180) * 0.5 * subOption.l)
                        , subOption.l
                        , 8
                        , -45 + subOption.directionDegrees * 180 / Math.PI
                        , `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          
      }

    else if (subOption.label === 'Add Dodecagon'){
                  elid = `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;



            const bcd = new PolygonTumpal(subOption.x + Math.cos(subOption.directionDegrees ) * (Math.tan(subOption.isoscelesAngle * Math.PI/180) * 0.5 * subOption.l + Math.tan(75 * Math.PI/180) * 0.5 * subOption.l )
                        , subOption.y + Math.sin(subOption.directionDegrees ) * (Math.tan(subOption.isoscelesAngle * Math.PI/180) * 0.5 * subOption.l + Math.tan(75 * Math.PI/180) * 0.5 * subOption.l)
                        , subOption.l
                        , 12
                        , -30 + subOption.directionDegrees * 180 / Math.PI
                        , `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          
      }


    else if (subOption.label === 'Add Heptagon'){
                  elid = `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;



            const bcd = new PolygonTumpal(subOption.x + Math.cos(subOption.directionDegrees ) * (Math.tan(subOption.isoscelesAngle * Math.PI/180) * 0.5 * subOption.l + Math.tan(64.2857142857 * Math.PI/180) * 0.5 * subOption.l )
                        , subOption.y + Math.sin(subOption.directionDegrees ) * (Math.tan(subOption.isoscelesAngle * Math.PI/180) * 0.5 * subOption.l + Math.tan(64.2857142857 * Math.PI/180) * 0.5 * subOption.l)
                        , subOption.l
                        , 7
                        , -64.2857142857 + subOption.directionDegrees * 180 / Math.PI
                        , `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          
      }


          menu.remove();
        });

        submenu.appendChild(subItem);
      });

      // Show submenu on hover
      menuItem.addEventListener("mouseenter", () => (submenu.style.display = "block"));
      menuItem.addEventListener("mouseleave", (e) => {
        setTimeout(() => {
          if (!submenu.matches(":hover") && !menuItem.matches(":hover")) {
            submenu.style.display = "none";
          }
        }, 100);
      });

      submenu.addEventListener("mouseenter", () => (submenu.style.display = "block"));
      submenu.addEventListener("mouseleave", () => (submenu.style.display = "none"));

      menuItem.appendChild(submenu);
    } else {
      // Normal menu item click event
      menuItem.addEventListener("click", () => {
        console.log(option.label + " selected");

    if (option.label === 'Remove'){
          removeSvgChildById(svg, option.id);

    }

      if (option.label === 'Add Square'){
          elid = `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;
            const bcd = new PolygonTumpal(option.x + Math.cos(option.directionDegrees ) * (Math.tan(option.isoscelesAngle * Math.PI/180) * 0.5 * option.l +  0.5 * option.l )
                        , option.y + Math.sin(option.directionDegrees ) * (Math.tan(option.isoscelesAngle * Math.PI/180) * 0.5 * option.l + 0.5 * option.l)
                        , option.l
                        , 4
                        , option.directionDegrees * 180 / Math.PI
                        , `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();

      }

    else if (option.label === 'Add Triangle'){

            const bcd = new PolygonTumpal(option.x + Math.cos(option.directionDegrees ) * (Math.tan(option.isoscelesAngle * Math.PI/180) * 0.5 * option.l + Math.tan(60 * Math.PI/180) * 0.5 * option.l/3 )
                        , option.y + Math.sin(option.directionDegrees ) * (Math.tan(option.isoscelesAngle * Math.PI/180) * 0.5 * option.l + Math.tan(60 * Math.PI/180) * 0.5 * option.l/3)
                        , option.l
                        , 3
                        , -30 + option.directionDegrees * 180 / Math.PI
                        , `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();


    }

      else if (option.label === 'Add Hexagon'){
                  elid = `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;



            const bcd = new PolygonTumpal(option.x + Math.cos(option.directionDegrees ) * (Math.tan(option.isoscelesAngle * Math.PI/180) * 0.5 * option.l + Math.tan(60 * Math.PI/180) * 0.5 * option.l )
                        , option.y + Math.sin(option.directionDegrees ) * (Math.tan(option.isoscelesAngle * Math.PI/180) * 0.5 * option.l + Math.tan(60 * Math.PI/180) * 0.5 * option.l)
                        , option.l
                        , 6
                        , -30 + option.directionDegrees * 180 / Math.PI
                        , `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
            bcd.draw();
          
      }






        menu.remove();
      });
    }

    menu.appendChild(menuItem);
  });

  document.body.appendChild(menu);

  // Close menu if clicking outside
  setTimeout(() => {
    document.addEventListener("click", function closeMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    });
  }, 0);
}







  function getRadius(side_length, n){
    theta = (2* Math.PI) / n;
    a = (Math.cos(2 * theta) - Math.cos(theta))** 2;
    b = (Math.sin(2 * theta) - Math.sin(theta))** 2;
    return side_length / Math.sqrt(a + b);
  }






class PolygonTumpal {
    /*
        Class to draw any n-gon decorated with traditional batik tumpal pattern. 
        cx: x center of circle circumscribing the polygon 
        cy: y center of circle circumscribing the polygon
        l: side length of the polygon 
        sides: number of sided of the polygon
        rotAngInDeg: rotation angle in degree 
        id: this object id for reference 
    */
    constructor(cx, cy, sideLength, sides, rotationDegrees = 0, id = 123) {
        this.cx = cx;
        this.cy = cy;
        this.sideLength = sideLength;
        this.sides = sides;
        this.rotationDegrees = rotationDegrees;
        this.id = id;
        this.isoscelesAngle = 90 - 180 / sides;
        this.r = getRadius(sideLength, sides);
        this.polygonPath = polygonAndStarPaths(this.sides, this.r, { cx: 0, cy: 0, k: 2 });
        if (sides >= 5){
            this.starOutlinePathString = starOutlinePath(this.sides, this.r, { cx: 0, cy: 0, k: 2 });
        }
    }

    radians(degree) {
        return (degree * Math.PI) / 180;
    }

    draw(){
        let patternType = document.getElementById("PatternType").value;


            if (patternType === 'Star') {
        let poly = document.createElementNS("http://www.w3.org/2000/svg", "path");
        poly.setAttribute("d", this.polygonPath);
        poly.setAttribute("fill", "#493118");
        poly.setAttribute("stroke", "none");
        poly.setAttribute("stroke-width", "2");
        poly.setAttribute("id", this.id);
        poly.setAttribute("transform", `translate(${this.cx}, ${this.cy}) rotate(${this.rotationDegrees})`);
        svg.appendChild(poly);

        }
        // Draw Batik Tumpal
        for (let i=0; i< this.sides; i++){




    if (patternType === 'Star') {


        if (this.sides >= 5) {
        let starOutline = document.createElementNS("http://www.w3.org/2000/svg", "path");
        starOutline.setAttribute("d", this.starOutlinePathString);
        starOutline.setAttribute("fill", "none");
        starOutline.setAttribute("stroke", "#d7c093");
        starOutline.setAttribute("stroke-width", "2");
        starOutline.setAttribute("id", this.id);
        starOutline.setAttribute("transform", `translate(${this.cx}, ${this.cy}) rotate(${this.rotationDegrees})`);
        svg.appendChild(starOutline);
        let x1 = this.r * Math.cos(2 * Math.PI/this.sides);
        let y1 = this.r * Math.sin(2 * Math.PI/this.sides);
        let x2 = this.r * Math.cos(2 * Math.PI/this.sides * 2);
        let y2 = this.r * Math.sin(2 * Math.PI/this.sides * 2);
        let dist = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
        for (let i=0; i <this.sides; i++){
            drawTumpalInner(this.cx, this.cy, this.id, this.r /2, 180 - 90 - (360 / this.sides) / 2 , 360/this.sides * i - 360/(2*this.sides) + this.rotationDegrees );
            let balancer = - Math.PI/2 - Math.PI/ (this.sides);
            let base = this.rotationDegrees * 2 * Math.PI / 360 - balancer;
            let aInner = base + (2 * Math.PI * i) / this.sides + Math.PI / this.sides;
            let rin = this.r * Math.cos((Math.PI * 2) / this.sides) / Math.cos(Math.PI / this.sides - (Math.PI * 2) / this.sides);
            let trig_deg = valleySideAngle(this.sides, 2).phiDegrees;
            drawTumpalStar(this.cx + rin * Math.cos(aInner), this.cy + rin * Math.sin(aInner), this.id, dist, trig_deg, 2 * trig_deg + 360/this.sides * i + this.rotationDegrees);
        }
        }

    }


        if (patternType === 'Moon'){
                drawAlternateTumpal(this.cx, this.cy, this.id, this.sideLength, this.isoscelesAngle, 360/this.sides * i  + this.rotationDegrees);
            }
            else if (patternType === 'Star' && this.sides < 5){
                 drawTumpalStar(this.cx, this.cy, this.id, this.sideLength, this.isoscelesAngle, 360/this.sides * i  + this.rotationDegrees);
            }
            else if (patternType === 'Sun'){
                 drawTumpal(this.cx, this.cy, this.id, this.sideLength, this.isoscelesAngle, 360/this.sides * i  + this.rotationDegrees);
            }
        }




        let height = Math.tan(this.isoscelesAngle * Math.PI/180) * 0.5 * this.sideLength;
        let width = 0.5 * this.sideLength;
        let degree = Math.atan2(height, width);




        for (let i=0; i< this.sides; i++){
            let outline1 = document.createElementNS(svgURI, "path");
            let outline_sentence1 = `M ${this.cx} ${this.cy} 
                        L ${this.cx + Math.cos(this.rotationDegrees * Math.PI/180 + degree + i * 2 * Math.PI/this.sides) * this.r} ${this.cy + Math.sin(this.rotationDegrees * Math.PI/180 + degree + i * 2 * Math.PI/this.sides) * this.r }
                        L ${this.cx + Math.cos(this.rotationDegrees * Math.PI/180 + degree + (i+1) * 2 * Math.PI/this.sides) * this.r } ${this.cy + Math.sin(this.rotationDegrees * Math.PI/180 + degree + (i+1) * 2 * Math.PI/this.sides) * this.r}
                        Z`;

            outline1.setAttribute("d", outline_sentence1);
            outline1.setAttribute("fill", "transparent");
            outline1.setAttribute("stroke", "transparent");
            outline1.setAttribute("stroke-width", "2");    // Ensures stroke is visible and hoverable
            outline1.setAttribute("pointer-events", "visiblePainted");
            svg.setAttribute("pointer-events", "none");
            outline1.setAttribute("z-index", "10");
            outline1.setAttribute("id", this.id);
            svg.appendChild(outline1);

            // Add event listeners for hover
            outline1.addEventListener("mouseover", () => {
              outline1.setAttribute("stroke", "gold"); // Change to hover color
            });


            outline1.addEventListener("mouseout", () => {
              outline1.setAttribute("stroke", "transparent"); // Reset to original color
            });


            outline1.addEventListener("click", (event) => {
            createContextMenu(event, [
            {
              label: "Add Triangle",
              x: this.cx,
              y: this.cy,
              l: this.sideLength,
              rotationDegrees: this.rotationDegrees,
              directionDegrees: ( (this.rotationDegrees * Math.PI/180 + degree + i * 2 * Math.PI/this.sides) + (this.rotationDegrees * Math.PI/180 + degree + (i+1) * 2 * Math.PI/this.sides))/2 ,
              neighborSides: this.sides,
              isoscelesAngle: this.isoscelesAngle
            },

            {
              label: "Add Square",
              x: this.cx,
              y: this.cy,
              l: this.sideLength,
              rotationDegrees: this.rotationDegrees,
              directionDegrees: ( (this.rotationDegrees * Math.PI/180 + degree + i * 2 * Math.PI/this.sides) + (this.rotationDegrees * Math.PI/180 + degree + (i+1) * 2 * Math.PI/this.sides))/2 ,
              neighborSides: this.sides,
              isoscelesAngle: this.isoscelesAngle
            },
            {
              label: "Add Hexagon",
              x: this.cx,
              y: this.cy,
              l: this.sideLength,
              rotationDegrees: this.rotationDegrees,
              directionDegrees: ( (this.rotationDegrees * Math.PI/180 + degree + i * 2 * Math.PI/this.sides) + (this.rotationDegrees * Math.PI/180 + degree + (i+1) * 2 * Math.PI/this.sides))/2 ,
              neighborSides: this.sides,
              isoscelesAngle: this.isoscelesAngle
            },
            {
            label: "Add Other Polygon",
            submenu: [
                {
                    label: "Add Pentagon",
                    x: this.cx,
                    y: this.cy,
                    l: this.sideLength,
                    rotationDegrees: this.rotationDegrees,
                    directionDegrees: ((this.rotationDegrees * Math.PI / 180 + degree + i * 2 * Math.PI / this.sides) +
                        (this.rotationDegrees * Math.PI / 180 + degree + (i + 1) * 2 * Math.PI / this.sides)) / 2,
                    neighborSides: this.sides,
                    isoscelesAngle: this.isoscelesAngle
                },

                {
                    label: "Add Octagon",
                    x: this.cx,
                    y: this.cy,
                    l: this.sideLength,
                    rotationDegrees: this.rotationDegrees,
                    directionDegrees: ( (this.rotationDegrees * Math.PI/180 + degree + i * 2 * Math.PI/this.sides) + (this.rotationDegrees * Math.PI/180 + degree + (i+1) * 2 * Math.PI/this.sides))/2 ,
                    neighborSides: this.sides,
                    isoscelesAngle: this.isoscelesAngle
                },
                {
                    label: "Add Heptagon",
                    x: this.cx,
                    y: this.cy,
                    l: this.sideLength,
                    rotationDegrees: this.rotationDegrees,
                    directionDegrees: ((this.rotationDegrees * Math.PI / 180 + degree + i * 2 * Math.PI / this.sides) +
                        (this.rotationDegrees * Math.PI / 180 + degree + (i + 1) * 2 * Math.PI / this.sides)) / 2,
                    neighborSides: this.sides,
                    isoscelesAngle: this.isoscelesAngle
                },

                {
                    label: "Add Dodecagon",
                    x: this.cx,
                    y: this.cy,
                    l: this.sideLength,
                    rotationDegrees: this.rotationDegrees,
                    directionDegrees: ( (this.rotationDegrees * Math.PI/180 + degree + i * 2 * Math.PI/this.sides) + (this.rotationDegrees * Math.PI/180 + degree + (i+1) * 2 * Math.PI/this.sides))/2 ,
                    neighborSides: this.sides,
                    isoscelesAngle: this.isoscelesAngle
                }
            ]

        },



            {
                label: "Remove",
                id: this.id
            },
            ]);
            });
        }


    }




}



    abc = new PolygonTumpal(svg.getAttribute("width")/2, svg.getAttribute("height")/2, svg.getAttribute("height")/5, 4, 0, `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`);
    abc.draw();

  </script>
  <script>
document.getElementById("CanvasSize").addEventListener("change", function() {
    const selectedOption = this.options[this.selectedIndex];
    const iconClass = selectedOption.getAttribute("data-icon");
    document.getElementById("canvas-icon").className = "fa-solid " + iconClass;
});
</script>
  <script src="/js/mainUI.js"></script> 
</body>
</html>
