<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern Spin 2 </title>
  <style>
    body {
      margin: 0;
      background: white;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

      path, rect, circle {
    pointer-events: none;
  }
  </style>
</head>
<body>
  <!-- SVG Canvas -->
  <svg id="game" width="400" height="600" style="background: #38445a;"></svg>
  <script>
const svgNS = "http://www.w3.org/2000/svg";
const svgURI = 'http://www.w3.org/2000/svg';
const svg = document.getElementById("game");
let life = true;
let rotationAngle = 0; // Initialize rotation angle
let touchStartX = 0;
let touchEndX = 0;
const maxSvgWidth = 400; // Maximum width in pixels
const maxSvgHeight = 700; // Maximum height in pixels
let showInstrution = true;



const audioCtx = new (window.AudioContext || window.webkitAudioContext)();


function playBeep() {
  // Ensure the AudioContext is resumed before playing sound
  if (audioCtx.state === "suspended") {
    audioCtx.resume().then(() => {
      generateBeep();
    });
  } else {
    generateBeep();
  }

  function generateBeep() {
 
    // modulation.stop(audioCtx.currentTime + 1);



  // Generate white noise buffer
  const bufferSize = audioCtx.sampleRate * 0.1; // Duration: 0.1 seconds
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  // Fill buffer with white noise
  for (let i = 0; i < bufferSize; i++) {
    data[i] = Math.random() * 2 - 1; // Random values between -1 and 1
  }

  // Create a buffer source to play the noise
  const noiseSource = audioCtx.createBufferSource();
  noiseSource.buffer = buffer;

  // Create a gain node to shape the snap envelope
  const gainNode = audioCtx.createGain();
  gainNode.gain.setValueAtTime(1, audioCtx.currentTime); // Start volume
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05); // Rapid fade-out

  // Connect nodes
  noiseSource.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  // Start noise playback and stop it after a short duration
  noiseSource.start();
  noiseSource.stop(audioCtx.currentTime + 0.1);


  }
}



function playCrash() {


  // Create a white noise buffer
  const bufferSize = audioCtx.sampleRate * 0.5; // Duration: 0.5 seconds
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  // Fill buffer with white noise
  for (let i = 0; i < bufferSize; i++) {
    data[i] = Math.random() * 2 - 1; // Random values between -1 and 1
  }

  // Create a buffer source to play the noise
  const noiseSource = audioCtx.createBufferSource();
  noiseSource.buffer = buffer;

  // Create a gain node to control the envelope
  const gainNode = audioCtx.createGain();
  gainNode.gain.setValueAtTime(1, audioCtx.currentTime); // Start loud
  gainNode.gain.exponentialRampToValueAtTime(0.1, audioCtx.currentTime + 0.1); // Quick decay
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4); // Fade out

  // Optional: Add a filter for a metallic effect
  const filter = audioCtx.createBiquadFilter();
  filter.type = "bandpass"; // Emulate the crash sound by emphasizing mid frequencies
  filter.frequency.setValueAtTime(1000, audioCtx.currentTime); // Center frequency
  filter.Q.setValueAtTime(5, audioCtx.currentTime); // Narrow band

  // Connect nodes
  noiseSource.connect(filter);
  filter.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  // Start the noise source and stop it after 0.5 seconds
  noiseSource.start();
  noiseSource.stop(audioCtx.currentTime + 0.5);
}



function playGameClear() {

  // Notes in the melody (frequency in Hz) and their durations
  const notes = [
    { freq: 523.25, duration: 0.2 }, // C5
    { freq: 659.25, duration: 0.2 }, // E5
    { freq: 783.99, duration: 0.2 }, // G5
    { freq: 1046.5, duration: 0.4 }, // C6 (hold longer)
  ];

  // Play each note in sequence
  let currentTime = audioCtx.currentTime;
  notes.forEach((note, index) => {
    const osc = audioCtx.createOscillator(); // Create an oscillator for the tone
    const gainNode = audioCtx.createGain();  // Create a gain node for volume control

    osc.type = "sine"; // Smooth, pleasant sound
    osc.frequency.setValueAtTime(note.freq, currentTime); // Set frequency
    gainNode.gain.setValueAtTime(0.3, currentTime); // Set initial volume

    // Slight fade-out for each note
    gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + note.duration);

    // Connect nodes and play the note
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.start(currentTime);
    osc.stop(currentTime + note.duration);

    // Increment the current time by the note's duration
    currentTime += note.duration;
  });
}






// Adjust SVG dimensions based on screen size
function adjustSvgSize() {
  const screenWidth = window.innerWidth;  // Current screen width
  const screenHeight = window.innerHeight; // Current screen height
  // Cap width and height
  const newWidth = Math.min(screenWidth, maxSvgWidth);
  const newHeight = Math.min(screenHeight, maxSvgHeight);
  // Update SVG attributes
  svg.setAttribute("width", newWidth);
  svg.setAttribute("height", newHeight);
}

// Adjust SVG size initially
adjustSvgSize();

// Re-adjust SVG size on window resize
window.addEventListener("resize", adjustSvgSize);


document.addEventListener('touchstart', (event) => {
  touchStartX = event.changedTouches[0].screenX;
});

document.addEventListener('touchend', (event) => {
  touchEndX = event.changedTouches[0].screenX;
  handleGesture();
});

function handleGesture() {
  const swipeThreshold = 15; // Minimum distance to consider as a swipe
  if (touchEndX < touchStartX - swipeThreshold) {
    rotateCounterClockwise();
    showInstrution = false;
    removeSvgChildById(svg, 'textTutorialInit2');
  } else if (touchEndX > touchStartX + swipeThreshold) {
    rotateClockwise();
    showInstrution = false;
    removeSvgChildById(svg, 'textTutorialInit2');
  }
}
    
    
    function removeSvgChildById(svgContainer, targetId) {
    // Get all child elements
    const children = svgContainer.children;
    // Loop through children in reverse and remove the ones with the matching ID
    for (let i = children.length - 1; i >= 0; i--) {
      if (children[i].getAttribute("id") === targetId) {
        svgContainer.removeChild(children[i]);
      }
    }
  }

    function getRadius(side_length, n){
      theta = (2* Math.PI) / n;
      a = (Math.cos(2 * theta) - Math.cos(theta))** 2;
      b = (Math.sin(2 * theta) - Math.sin(theta))** 2;
      return side_length / Math.sqrt(a + b);
    }

function hasSameEdge(square, hexagon) {
  // Helper function to check if two edges are within a tolerance
  function isSameEdge(edge1, edge2, epsilon = 0.5) {
    // Edge1: [[x1, y1], [x2, y2]]
    // Edge2: [[x3, y3], [x4, y4]]
    const [[x1, y1], [x2, y2]] = edge1;
    const [[x3, y3], [x4, y4]] = edge2;

    const arePointsClose = (x1, y1, x2, y2) =>
      Math.abs(x1 - x2) <= epsilon && Math.abs(y1 - y2) <= epsilon;

    return (
      (arePointsClose(x1, y1, x3, y3) && arePointsClose(x2, y2, x4, y4)) || // Same direction
      (arePointsClose(x1, y1, x4, y4) && arePointsClose(x2, y2, x3, y3))    // Reversed direction
    );
  }

  // Extract edges from both objects
  // function getEdges(vertices) {
  //   const edges = [];
  //   for (let i = 0; i < vertices.length; i++) {
  //     const start = vertices[i];
  //     const end = vertices[(i + 1) % vertices.length];
  //     edges.push([start, end]);
  //   }
  //   return edges;
  // }

  // const squareEdges = getEdges(square.vertices);
  // const hexagonEdges = getEdges(hexagon.vertices);

  squareEdges = square.edges;
  hexagonEdges = hexagon.edges;

  // Check for common edges with tolerance
  for (const squareEdge of squareEdges) {
    for (const hexEdge of hexagonEdges) {
      if (isSameEdge(squareEdge, hexEdge)) {
        return true; // A matching edge within tolerance was found
      }
    }
  }

  return false; // No matching edges
}

function getOverlappingEdge(square, hexagon) {
  // Helper function to check if two edges are within a tolerance
  function isSameEdge(edge1, edge2, epsilon = 0.5) {
    // Edge1: [[x1, y1], [x2, y2]]
    // Edge2: [[x3, y3], [x4, y4]]
    const [[x1, y1], [x2, y2]] = edge1;
    const [[x3, y3], [x4, y4]] = edge2;

    const arePointsClose = (x1, y1, x2, y2) =>
      Math.abs(x1 - x2) <= epsilon && Math.abs(y1 - y2) <= epsilon;

    return (
      (arePointsClose(x1, y1, x3, y3) && arePointsClose(x2, y2, x4, y4)) || // Same direction
      (arePointsClose(x1, y1, x4, y4) && arePointsClose(x2, y2, x3, y3))    // Reversed direction
    );
  }

  // Directly using edges from objects
  const squareEdges = square.edges;
  const hexagonEdges = hexagon.edges;

  // Check for common edges with tolerance
  for (const squareEdge of squareEdges) {
    for (const hexEdge of hexagonEdges) {
      if (isSameEdge(squareEdge, hexEdge)) {
        return squareEdge; // Return the overlapping edge
      }
    }
  }

  return null; // No overlapping edges found
}




function edgesIntersect(edge1, edge2) {
  const [p1, q1] = edge1; // First edge points
  const [p2, q2] = edge2; // Second edge points

  // Helper to find orientation of ordered triplet (p, q, r)
  function orientation(p, q, r) {
    const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    if (val === 0) return 0; // Collinear
    return val > 0 ? 1 : 2; // Clockwise or Counterclockwise
  }

  // Helper to check if point q lies on segment pr
  function onSegment(p, q, r) {
    return (
      q[0] >= Math.min(p[0], r[0]) && q[0] <= Math.max(p[0], r[0]) &&
      q[1] >= Math.min(p[1], r[1]) && q[1] <= Math.max(p[1], r[1])
    );
  }

  const o1 = orientation(p1, q1, p2);
  const o2 = orientation(p1, q1, q2);
  const o3 = orientation(p2, q2, p1);
  const o4 = orientation(p2, q2, q1);

  // General case: If orientations are different, the edges intersect
  if (o1 !== o2 && o3 !== o4) return true;

  // Special cases: Check if any point of one segment lies on the other segment
  // if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  // if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  // if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  // if (o4 === 0 && onSegment(p2, q1, q2)) return true;

  // No intersection
  return false;
}


function drawHint(x, y, id = 123, s = 200, trig_degree = 30, rotDeg= 0, mainColor="#b49084", secondaryColor="#586b8c", strokeColor = "gold", use_outline=false, tertiaryColor = "gold"){  
      let container = document.createElementNS(svgURI, "g");
      container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
      container.setAttribute("stroke-width", 0.5);
      container.setAttribute("id", id);
      svg.appendChild(container);
      let r = getRadius(s, 12);
      sentence = ''


      for(let i = 0; i<12; i++){
        if (i === 0){
          sentence += `M${Math.cos(i * 2 * Math.PI/12) * r} ${Math.sin(i * 2 * Math.PI/12) * r}`
        }
        else{
          sentence += `L${Math.cos(i * 2 * Math.PI/12) * r} ${Math.sin(i * 2 * Math.PI/12) * r}`
        }

      }

      sentence += 'Z';
      let outline = document.createElementNS(svgURI, "path");
      outline.setAttribute("d", sentence);
      outline.setAttribute("fill", secondaryColor);
      outline.setAttribute("stroke", strokeColor);
      container.appendChild(outline);
}


    function drawHexagon(x, y, id = 123, s = 200, trig_degree = 60, rotDeg= 0, mainColor="#b49084", secondaryColor="#38445a", strokeColor = "gold", use_outline=false, tertiaryColor = "gold", use_middle_upper=true){  
      let container = document.createElementNS(svgURI, "g");
      container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
      container.setAttribute("stroke-width", 0.01);
      container.setAttribute("id", id);
      svg.appendChild(container);
      const h = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s);
      let outline = document.createElementNS(svgURI, "path");
      outline_sentence = `M0 0  ${0.5 * s} ${h}  ${-0.5 * s} ${h} Z`;
      outline.setAttribute("d", outline_sentence);
      outline.setAttribute("fill", "none");
      outline.setAttribute("stroke", strokeColor);
      if (use_outline){
          container.appendChild(outline);
      }
      
      R = s / 10;
      Xc = 0.5 * s - R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI);
      R_new = 2 * R;
      tpl_pth = `M0 ${h}  C ${Xc * 0.5} ${h}  ${Xc * 0.5} ${h - 2*R} ${Xc} ${h - 2* R} A${R} ${R} 0 0 1 ${Xc} ${h} A ${0.5 * R} ${0.5* R} 0 0 1 ${Xc} ${h - R} C${Xc - R} ${h - R} ${Xc - R} ${h}  ${Xc - 2 * R} ${h} Z`;
      tpl = document.createElementNS(svgURI, "path");
      tpl.setAttribute("d", tpl_pth);
      tpl.setAttribute("fill", mainColor);
      tpl.setAttribute("stroke", strokeColor);
      container.appendChild(tpl);
      tpl2 = tpl.cloneNode(true);
      tpl2.setAttribute("transform", "scale(-1 1)");
      container.appendChild(tpl2);
      tpl3 = tpl.cloneNode(true);
      tpl3_pth = `M${0} ${h}  C ${0} ${h - Xc * 0.5}  ${2 * R} ${h - Xc * 0.5} ${2 * R} ${h - Xc}  A${R} ${R} 0 0 0 ${0} ${h - Xc} A${0.5 * R} ${0.5 * R} 0 0 0 ${R} ${h - Xc} C ${R}  ${h - 0.6 * Xc} ${0}  ${h - 0.6 * Xc}  ${0}  ${h -0.2 *  Xc} `;
      tpl3.setAttribute("d", tpl3_pth);
      tpl3.setAttribute("fill", "#e8eadd");
      tpl4 = tpl.cloneNode(true);
      tpl4.setAttribute("transform", `rotate(-90 0 ${h})`);
      tpl4.setAttribute("fill", "#e8eadd");
      container.appendChild(tpl3);
      container.appendChild(tpl4);
      tpl5 = tpl.cloneNode(true);
      tpl5.setAttribute("d", `M 0 0 C 0 ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new}  ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new} ${h - Xc - R - 0.4 * R_new} A${0.2 * R_new} ${0.2 * R_new} 0 0 0 ${0} ${h - Xc - R - 0.4 * R_new} A${0.4 * R_new} ${0.4 * R_new} 0 0 0 ${0.8 * R_new} ${ h - Xc - R - 0.4 * R_new} C${0.8 * R_new} ${0.5 * (h - Xc - R - 0.4 * R_new) } ${0} ${0.5 * (h - Xc - R - 0.4 * R_new)} 0 0`);
      tpl6 = tpl5.cloneNode(true);
      tpl6.setAttribute("transform", `scale(-1, 1)`);
      container.appendChild(tpl5);
      container.appendChild(tpl6);

      for (let i = 1; i <= 6; i++) {
        const tplClone = tpl.cloneNode(true); // Clone the element
        const rotation = 60 * i; // Calculate the rotation degree
        tplClone.setAttribute("transform", `rotate(${rotation})`); // Set the rotation
        container.appendChild(tplClone); // Append the cloned and transformed element to the container
        const tpl2Clone = tpl.cloneNode(true); // Clone the element
        tpl2Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl2Clone); // Append the cloned and transformed element to the container
        const tpl3Clone = tpl3.cloneNode(true); // Clone the element
        tpl3Clone.setAttribute("transform", `rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl3Clone); // Append the cloned and transformed element to the container
        const tpl4Clone = tpl3.cloneNode(true); // Clone the element
        tpl4Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl4Clone); // Append the cloned and transformed element to the container
        const tpl5Clone = tpl5.cloneNode(true); // Clone the element
        tpl5Clone.setAttribute("transform", `scale(1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl5Clone); // Append the cloned and transformed element to the container
        const tpl6Clone = tpl5.cloneNode(true); // Clone the element
        tpl6Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl6Clone); // Append the cloned and transformed element to the container
      }
}


    function drawSquare(x, y, id = 123, s = 200, trig_degree = 45, rotDeg= 0, mainColor="#b49084", secondaryColor="#38445a", strokeColor = "gold", use_outline=false, tertiaryColor = "gold", use_middle_upper=true){  
      let container = document.createElementNS(svgURI, "g");
      container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
      container.setAttribute("stroke-width", 0.1);
      container.setAttribute("id", id);
      svg.appendChild(container);
      const h = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s);
      let outline = document.createElementNS(svgURI, "path");
      outline_sentence = `M0 0  ${0.5 * s} ${h}  ${-0.5 * s} ${h} Z`;
      outline.setAttribute("d", outline_sentence);
      outline.setAttribute("fill", "none");
      outline.setAttribute("stroke", strokeColor);
      if (use_outline){
          container.appendChild(outline);
      }
      
      R = s / 10;
      Xc = 0.5 * s - R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI);
      R_new =  R;
      tpl_pth = `M0 ${h}  C ${Xc * 0.5} ${h}  ${Xc * 0.5} ${h - 2*R} ${Xc} ${h - 2* R} A${R} ${R} 0 0 1 ${Xc} ${h} A ${0.5 * R} ${0.5* R} 0 0 1 ${Xc} ${h - R} C${Xc - R} ${h - R} ${Xc - R} ${h}  ${Xc - 2 * R} ${h} Z`;
      tpl = document.createElementNS(svgURI, "path");
      tpl.setAttribute("d", tpl_pth);
      tpl.setAttribute("fill", mainColor);
      tpl.setAttribute("stroke", strokeColor);
      container.appendChild(tpl);
      tpl2 = tpl.cloneNode(true);
      tpl2.setAttribute("transform", "scale(-1 1)");
      container.appendChild(tpl2);
      tpl3 = tpl.cloneNode(true);
      tpl3_pth = `M${0} ${h}  C ${0} ${h - Xc * 0.5}  ${2 * R} ${h - Xc * 0.5} ${2 * R} ${h - Xc}  A${R} ${R} 0 0 0 ${0} ${h - Xc} A${0.5 * R} ${0.5 * R} 0 0 0 ${R} ${h - Xc} C ${R}  ${h - 0.6 * Xc} ${0}  ${h - 0.6 * Xc}  ${0}  ${h -0.2 *  Xc} `;
      tpl3.setAttribute("d", tpl3_pth);
      tpl3.setAttribute("fill", "#e8eadd");
      tpl4 = tpl.cloneNode(true);
      tpl4.setAttribute("transform", `rotate(-90 0 ${h})`);
      tpl4.setAttribute("fill", "#e8eadd");
      container.appendChild(tpl3);
      container.appendChild(tpl4);
      tpl5 = tpl.cloneNode(true);
      tpl5.setAttribute("d", `M 0 0 C 0 ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new}  ${ 0.5 * (h - Xc - R - 0.4 * R_new) } ${0.4 * R_new} ${h - Xc - R - 0.4 * R_new} A${0.2 * R_new} ${0.2 * R_new} 0 0 0 ${0} ${h - Xc - R - 0.4 * R_new} A${0.4 * R_new} ${0.4 * R_new} 0 0 0 ${0.8 * R_new} ${ h - Xc - R - 0.4 * R_new} C${0.8 * R_new} ${0.5 * (h - Xc - R - 0.4 * R_new) } ${0} ${0.5 * (h - Xc - R - 0.4 * R_new)} 0 0`);
      tpl6 = tpl5.cloneNode(true);
      tpl6.setAttribute("transform", `scale(-1, 1)`);
      container.appendChild(tpl5);
      container.appendChild(tpl6);

      for (let i = 1; i <= 4; i++) {
        const tplClone = tpl.cloneNode(true); // Clone the element
        const rotation = 90 * i; // Calculate the rotation degree
        tplClone.setAttribute("transform", `rotate(${rotation})`); // Set the rotation
        container.appendChild(tplClone); // Append the cloned and transformed element to the container
        const tpl2Clone = tpl.cloneNode(true); // Clone the element
        tpl2Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl2Clone); // Append the cloned and transformed element to the container
        const tpl3Clone = tpl3.cloneNode(true); // Clone the element
        tpl3Clone.setAttribute("transform", `rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl3Clone); // Append the cloned and transformed element to the container
        const tpl4Clone = tpl3.cloneNode(true); // Clone the element
        tpl4Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl4Clone); // Append the cloned and transformed element to the container
        const tpl5Clone = tpl5.cloneNode(true); // Clone the element
        tpl5Clone.setAttribute("transform", `scale(1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl5Clone); // Append the cloned and transformed element to the container
        const tpl6Clone = tpl5.cloneNode(true); // Clone the element
        tpl6Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl6Clone); // Append the cloned and transformed element to the container
      }


  }



function drawTriangle(x, y, id = 123, s = 200, trig_degree = 30, rotDeg= 0, mainColor="#b49084", secondaryColor="#38445a", strokeColor = "gold", use_outline=false, tertiaryColor = "gold", use_middle_upper=true){  
      let container = document.createElementNS(svgURI, "g");
      container.setAttribute("transform", `translate(${x}, ${y}) rotate(${rotDeg})`);
      container.setAttribute("stroke-width", 0.1);
      container.setAttribute("id", id);
      svg.appendChild(container);
      const h = Math.tan(trig_degree/360 * 2 * Math.PI) * (0.5 * s);
      let outline = document.createElementNS(svgURI, "path");
      outline_sentence = `M0 0  ${0.5 * s} ${h}  ${-0.5 * s} ${h} Z`;
      outline.setAttribute("d", outline_sentence);
      outline.setAttribute("fill", "none");
      outline.setAttribute("stroke", strokeColor);
      if (use_outline){
          container.appendChild(outline);
      }
      
      R = s /15;
      Xc = 0.5 * s - R / Math.tan(0.5 * trig_degree/360 * 2 * Math.PI);
      R_new =  R;
      tpl_pth = `M0 ${h}  C ${Xc * 0.5} ${h}  ${Xc * 0.5} ${h - 2*R} ${Xc} ${h - 2* R} A${R} ${R} 0 0 1 ${Xc} ${h} A ${0.5 * R} ${0.5* R} 0 0 1 ${Xc} ${h - R} C${Xc - R} ${h - R} ${Xc - R} ${h}  ${Xc - 2 * R} ${h} Z`;
      tpl = document.createElementNS(svgURI, "path");
      tpl.setAttribute("d", tpl_pth);
      tpl.setAttribute("fill", mainColor);
      tpl.setAttribute("stroke", strokeColor);
      container.appendChild(tpl);
      tpl2 = tpl.cloneNode(true);
      tpl2.setAttribute("transform", "scale(-1 1)");
      container.appendChild(tpl2);
      tpl3 = tpl.cloneNode(true);
      tpl3_pth = `M ${0} ${h} C ${0} ${h- 0.3 * (2 * R + s/30)} ${s/30} ${h- 0.3 * (2 * R + s/30)}  ${s/30} ${h-2 * R + s/30} A ${s/60} ${s/60} 0 0 1 ${0} ${h-2 * R + s /30} A${s/30} ${s/30} 0 0 1 ${2 * s/30} ${h-2 * R + s /30} C${2 * s/30} ${h- 0.3 * (2 * R + s/30)} ${0} ${h- 0.3 * (2 * R + s/30)} ${0} ${h}  `;

      tpl3.setAttribute("d", tpl3_pth);
      tpl3.setAttribute("fill", "#e8eadd");
      tpl4 = tpl3.cloneNode(true);
      tpl4.setAttribute("transform", `scale(-1 1)`);
      tpl4.setAttribute("fill", "#e8eadd");
      container.appendChild(tpl3);
      container.appendChild(tpl4);
      tpl5 = tpl.cloneNode(true);
      tpl5.setAttribute("d", `M ${0} ${0} C ${0} ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${0.5 *  (h-2 * R - s /30) }  ${s/30}  ${h-2 * R - s /30} A${s / 60} ${s / 60} 0 0 0 ${0} ${h-2 * R - s /30} A${s / 30} ${s / 30} 0 0 0 ${2 * s / 30} ${h-2 * R - s /30} C ${2 * s / 30} ${ 0.5 *  (h-2 * R - s /30) } ${0} ${ 0.5 *  (h-2 * R - s /30) }   ${0} ${0}`);
      tpl6 = tpl5.cloneNode(true);
      tpl6.setAttribute("transform", `scale(-1, 1)`);
      container.appendChild(tpl5);
      container.appendChild(tpl6);

      for (let i = 1; i <= 3; i++) {
        const tplClone = tpl.cloneNode(true); // Clone the element
        const rotation = 120 * i; // Calculate the rotation degree
        tplClone.setAttribute("transform", `rotate(${rotation})`); // Set the rotation
        container.appendChild(tplClone); // Append the cloned and transformed element to the container
        const tpl2Clone = tpl.cloneNode(true); // Clone the element
        tpl2Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl2Clone); // Append the cloned and transformed element to the container
        const tpl3Clone = tpl3.cloneNode(true); // Clone the element
        tpl3Clone.setAttribute("transform", `rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl3Clone); // Append the cloned and transformed element to the container
        const tpl4Clone = tpl3.cloneNode(true); // Clone the element
        tpl4Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl4Clone); // Append the cloned and transformed element to the container
        const tpl5Clone = tpl5.cloneNode(true); // Clone the element
        tpl5Clone.setAttribute("transform", `scale(1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl5Clone); // Append the cloned and transformed element to the container
        const tpl6Clone = tpl5.cloneNode(true); // Clone the element
        tpl6Clone.setAttribute("transform", `scale(-1 1) rotate(${rotation})`); // Set the rotation
        container.appendChild(tpl6Clone); // Append the cloned and transformed element to the container
      }


  }



  class HexagonTumpal {
        constructor(cx, cy, l, motive , rot_deg = 0, id = 123) {
          this.cx = cx;
          this.cy = cy;
          this.l = l;
          this.motive = motive;
          this.rot_deg = rot_deg * 2 * Math.PI / 360;
          this.rot_degree = rot_deg;
          this.id = id;
          this.r = getRadius(this.l , 6);
          this.vertices = [
                             [this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 0 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  0   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 1 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  1   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 2 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  2   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 3 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  3   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 4 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  4   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 5 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  5   * Math.PI/3)]
                          ];
          this.edges = [ 

                           [[this.vertices[0][0], this.vertices[0][1]] , [this.vertices[1][0], this.vertices[1][1]]] // bottom
                          ,[[this.vertices[1][0], this.vertices[1][1]] , [this.vertices[2][0], this.vertices[2][1]]] // bottom left
                          ,[[this.vertices[2][0], this.vertices[2][1]] , [this.vertices[3][0], this.vertices[3][1]]] // upper left
                          ,[[this.vertices[3][0], this.vertices[3][1]] , [this.vertices[4][0], this.vertices[4][1]]] // up
                          ,[[this.vertices[4][0], this.vertices[4][1]] , [this.vertices[5][0], this.vertices[5][1]]] // upper right
                          ,[[this.vertices[5][0], this.vertices[5][1]] , [this.vertices[0][0], this.vertices[0][1]]] // upper left
          ]

          this.bottomNeighbor= null; 
          this.upperNeighbor= null; 
          this.upperLeftNeighbor = null;
          this.bottomLeftNeighbor = null;
          this.upperRightNeighbor = null;
          this.bottomRightNeighbor = null;


        }

      draw() {
          drawHexagon(this.cx, this.cy, this.id, this.l, 60, 0 + this.rot_degree, "#b49084", "#38445a", "gold", false, "gold");
          let outline1 = document.createElementNS(svgURI, "path");
          let outline_sentence1 = `
                        M ${this.vertices[0][0] } ${this.vertices[0][1]}
                        L ${this.vertices[1][0] } ${this.vertices[1][1]}
                        L ${this.vertices[2][0] } ${this.vertices[2][1]}
                        L ${this.vertices[3][0] } ${this.vertices[3][1]}
                        L ${this.vertices[4][0] } ${this.vertices[4][1]}
                        L ${this.vertices[5][0] } ${this.vertices[5][1]}

                        Z`;
          outline1.setAttribute("d", outline_sentence1);
          outline1.setAttribute("fill", "transparent");
          outline1.setAttribute("stroke", "gold");
          outline1.setAttribute("stroke-width", 0.5);
          outline1.setAttribute("id", this.id);
          svg.appendChild(outline1);


      }
      update(){
        
          for (const obj of objList) {

            if (getOverlappingEdge(this, obj) !== null && this.id != obj.id){
              // console.log(getOverlappingEdge(this, obj));
         
              if (this.edges[0] === getOverlappingEdge(this, obj)){
                this.bottomNeighbor = obj;
                this.bottomNeighborDist = Math.sqrt((this.cx - this.bottomNeighbor.cx) ** 2 + (this.cy - this.bottomNeighbor.cy) ** 2) ;
              }  
   
              if (this.edges[1] === getOverlappingEdge(this, obj)){
                this.bottomLeftNeighbor = obj;
                this.bottomLeftNeighborDist = Math.sqrt((this.cx - this.bottomLeftNeighbor.cx) ** 2 + (this.cy - this.bottomLeftNeighbor.cy) ** 2) ;
              }  

              if (this.edges[2] === getOverlappingEdge(this, obj)){
                this.upperLeftNeighbor = obj;
                this.upperLeftNeighborDist = Math.sqrt((this.cx - this.upperLeftNeighbor.cx) ** 2 + (this.cy - this.upperLeftNeighbor.cy) ** 2) ;
              }
              else if (this.edges[3] === getOverlappingEdge(this, obj)){
                this.upperNeighbor = obj;

                if (this.upperNeighbor.motive === 'triangle'){
                  // this.upperNeighborDist = Math.sqrt((this.cx - this.upperNeighbor.cx) ** 2 + (this.cy - this.upperNeighbor.cy) ** 2) ;
                  this.upperNeighborDist = 4 /3 *  Math.sin(60 * 2 * Math.PI/ 360) * this.l;
                }
                else {
                  this.upperNeighborDist = Math.sqrt((this.cx - this.upperNeighbor.cx) ** 2 + (this.cy - this.upperNeighbor.cy) ** 2) ;
                }

              }

              else if (this.edges[4] === getOverlappingEdge(this, obj)){
                this.upperRightNeighbor = obj;
                this.upperRightNeighborDist = Math.sqrt((this.cx - this.upperRightNeighbor.cx) ** 2 + (this.cy - this.upperRightNeighbor.cy) ** 2) ;
              }
              else if (this.edges[5] === getOverlappingEdge(this, obj)){
                this.bottomRightNeighbor = obj;
                this.bottomRightNeighborDist = Math.sqrt((this.cx - this.bottomRightNeighbor.cx) ** 2 + (this.cy - this.bottomRightNeighbor.cy) ** 2) ;
              }


            }






            if (hasSameEdge(this, obj) && this.id != obj.id) {
              this.is_collision = true;
            }

            
          }



      }

    }


  class HintGuideline {
        constructor(cx, cy, l, motive , rot_deg = 0, id = 123) {
          this.cx = cx;
          this.cy = cy;
          this.l = l;
          this.motive = motive;
          this.rot_deg = rot_deg * 2 * Math.PI / 360;
          this.rot_degree = rot_deg;
          this.id = id;
          this.r = getRadius(this.l , 6);
          this.vertices = [
                             [this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 0 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  0   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 1 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  1   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 2 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  2   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 3 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  3   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 4 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  4   * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/3 + 5 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/3 +  5   * Math.PI/3)]
                          ];
          this.edges = [ 

                           [[this.vertices[0][0], this.vertices[0][1]] , [this.vertices[1][0], this.vertices[1][1]]] // bottom
                          ,[[this.vertices[1][0], this.vertices[1][1]] , [this.vertices[2][0], this.vertices[2][1]]] // bottom left
                          ,[[this.vertices[2][0], this.vertices[2][1]] , [this.vertices[3][0], this.vertices[3][1]]] // upper left
                          ,[[this.vertices[3][0], this.vertices[3][1]] , [this.vertices[4][0], this.vertices[4][1]]] // up
                          ,[[this.vertices[4][0], this.vertices[4][1]] , [this.vertices[5][0], this.vertices[5][1]]] // upper right
                          ,[[this.vertices[5][0], this.vertices[5][1]] , [this.vertices[0][0], this.vertices[0][1]]] // upper left
          ]

        }

      draw() {
          drawHint(this.cx, this.cy, this.id, this.l, 60, 0 + this.rot_degree, "#b49084", "none", "gold", false, "gold");
      }
      update(){
      }

    }



      class SquareTumpal {
        constructor(cx, cy, l, motive , rot_deg = 0, id = 123) {
          this.cx = cx;
          this.cy = cy;
          this.l = l;
          this.motive = motive;
          this.rot_deg = rot_deg * 2 * Math.PI / 360;
          this.rot_degree = rot_deg;
          this.id = id;
          this.is_collision = false;
          this.r = getRadius(this.l , 4);
          this.vertices = [
                             [this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 0 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  0   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 1 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  1   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 2 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  2   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 3 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  3   * Math.PI/2)]

                          ];
          this.edges = [ 

                           [[this.vertices[0][0], this.vertices[0][1]] , [this.vertices[1][0], this.vertices[1][1]]] // bottom
                          ,[[this.vertices[1][0], this.vertices[1][1]] , [this.vertices[2][0], this.vertices[2][1]]] // left
                          ,[[this.vertices[2][0], this.vertices[2][1]] , [this.vertices[3][0], this.vertices[3][1]]] // up
                          ,[[this.vertices[3][0], this.vertices[3][1]] , [this.vertices[0][0], this.vertices[0][1]]] // right
          ]
          this.bottomNeighbor = null;
          this.LeftNeighbor = null;
          this.RightNeighbor = null;

        }



        draw() {
          this.vertices = [
                             [this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 0 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  0   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 1 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  1   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 2 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  2   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 3 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  3   * Math.PI/2)]

                          ];
          this.edges = [ 

                           [[this.vertices[0][0], this.vertices[0][1]] , [this.vertices[1][0], this.vertices[1][1]]] // bottom
                          ,[[this.vertices[1][0], this.vertices[1][1]] , [this.vertices[2][0], this.vertices[2][1]]] // left
                          ,[[this.vertices[2][0], this.vertices[2][1]] , [this.vertices[3][0], this.vertices[3][1]]] // up
                          ,[[this.vertices[3][0], this.vertices[3][1]] , [this.vertices[0][0], this.vertices[0][1]]] // right
          ]
          drawSquare(this.cx, this.cy, this.id, this.l, 45, 0 + this.rot_degree, "#b49084", "#38445a", "gold", false, "gold");
          let outline1 = document.createElementNS(svgURI, "path");
          let outline_sentence1 = `
                        M ${this.vertices[0][0] } ${this.vertices[0][1]}
                        L ${this.vertices[1][0] } ${this.vertices[1][1]}
                        L ${this.vertices[2][0] } ${this.vertices[2][1]}
                        L ${this.vertices[3][0] } ${this.vertices[3][1]}
                        Z`;
          outline1.setAttribute("d", outline_sentence1);
          outline1.setAttribute("fill", "transparent");
          outline1.setAttribute("stroke", "gold");
          outline1.setAttribute("id", this.id);
          outline1.setAttribute("stroke-width", 0.5);
          svg.appendChild(outline1);
        }
        update(){
            this.vertices = [
                             [this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 0 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  0   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 1 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  1   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 2 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  2   * Math.PI/2)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  + Math.PI/4 + 3 *  Math.PI/2), this.cy + this.r * Math.sin(this.rot_deg + Math.PI/4 +  3   * Math.PI/2)]

            ];
            this.edges = [ 

                           [[this.vertices[0][0], this.vertices[0][1]] , [this.vertices[1][0], this.vertices[1][1]]] // bottom
                          ,[[this.vertices[1][0], this.vertices[1][1]] , [this.vertices[2][0], this.vertices[2][1]]] // left
                          ,[[this.vertices[2][0], this.vertices[2][1]] , [this.vertices[3][0], this.vertices[3][1]]] // up
                          ,[[this.vertices[3][0], this.vertices[3][1]] , [this.vertices[0][0], this.vertices[0][1]]] // right
           ]



          if (this.is_collision === false){
            this.cy += 1;
          }




          for (const obj of objList) {
              if (getOverlappingEdge(this, obj) !== null && this.id != obj.id){
              // console.log(getOverlappingEdge(this, obj));
              

              if (this.edges[0] === getOverlappingEdge(this, obj) && this.bottomNeighbor === null  ){
                this.bottomNeighbor = obj;
                this.isLinked = true;
                                playBeep();

                if (obj.motive === 'hexagon'){
                    this.cy = obj.cy - 3 /3 *  Math.sin(60 * 2 * Math.PI/ 360) * this.l - 0.5 * this.l;
                  }
                }


              if (this.edges[1] === getOverlappingEdge(this, obj) && this.LeftNeighbor === null  ){
                console.log("Zukkkyyyy");
                this.LeftNeighbor = obj;
                this.isLinked = true;
                playBeep();
                }

              if (this.edges[3] === getOverlappingEdge(this, obj) && this.RightNeighbor === null  ){
                console.log("Zukkkyyyy");
                this.RightNeighbor = obj;
                this.isLinked = true;
                playBeep();
                }
            
            }
          }





          for (let obj of objList) {
            if (hasSameEdge(this, obj) && this.id != obj.id) {
              this.is_collision = true;
              break;
            }



            for (let edge1 of this.edges){
              for (let edge2 of obj.edges){
                  if (edgesIntersect(edge1, edge2) === true && this.id != obj.id  ) {
  

                  if (obj.isLinked === true && this.isLinked === true) {
                  console.log("Both objects are linked, continuing...");
                  continue;
                  }

                  if ( ((edge1[0][0] === edge2[1][0] && edge1[0][1] === edge2[1][1]) || (edge1[1][0] === edge2[0][0] && edge1[1][1] === edge2[0][1])) ) {
                  console.log("Shared endpoint detected, skipping...");
                                                console.log("Skipped Objects:", this.id, obj.id);

                  continue;
                  }

                                    if ( !((edge1[0][0] === edge2[1][0] && edge1[0][1] === edge2[1][1]) || (edge1[1][0] === edge2[0][0] && edge1[1][1] === edge2[0][1])) ) {

                        this.is_collision = true;
                        console.log("Chiho Zukky!");
                        console.log(obj);
                        life = false;
                              console.log("Objects:", this.id, obj.id);
                              console.log(((edge1[0][0] === edge2[1][0] && edge1[0][1] === edge2[1][1]) || (edge1[1][0] === edge2[0][0] && edge1[1][1] === edge2[0][1])));
                              console.log(edge1, edge2);

                            }


                      
                  }
              }
            }










          }



        }
    }



      class TriangleTumpal {
        constructor(cx, cy, l, motive , rot_deg = 0, id = 123) {
          this.cx = cx;
          this.cy = cy;
          this.l = l;
          this.motive = motive;
          this.rot_deg = rot_deg * Math.PI / 180;
          this.rot_degree = rot_deg;
          this.id = id;
          this.is_collision = false;
          this.r = getRadius(this.l , 3);
          this.vertices = [
                             [this.cx + this.r * Math.cos(this.rot_deg - 3 * Math.PI/6 + 0 *  2 * Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  0   * 2 * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg - 3 * Math.PI/6 + 1 *  2 * Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  1   * 2 * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg - 3 * Math.PI/6 + 2 *  2 * Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  2   * 2 * Math.PI/3)]

                          ];
          this.edges = [ 

                           [[this.vertices[0][0], this.vertices[0][1]] , [this.vertices[1][0], this.vertices[1][1]]] // bottom
                          ,[[this.vertices[1][0], this.vertices[1][1]] , [this.vertices[2][0], this.vertices[2][1]]] // left
                          ,[[this.vertices[2][0], this.vertices[2][1]] , [this.vertices[0][0], this.vertices[0][1]]] // up
          ]
          this.bottomNeighbor = null;
          this.rightNeighbor = null;
          this.neighbors = [];
          this.isLinked = false;
        }



        draw() {
          this.vertices = [
                             [this.cx + this.r * Math.cos(this.rot_deg - 3 * Math.PI/6 + 0 *  2 * Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  0   * 2 * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg - 3 * Math.PI/6 + 1 *  2 * Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  1   * 2 * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg - 3 * Math.PI/6 + 2 *  2 * Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  2   * 2 * Math.PI/3)]

                          ];
          this.edges = [ 

                           [[this.vertices[0][0], this.vertices[0][1]] , [this.vertices[1][0], this.vertices[1][1]]] // bottom
                          ,[[this.vertices[1][0], this.vertices[1][1]] , [this.vertices[2][0], this.vertices[2][1]]] // left
                          ,[[this.vertices[2][0], this.vertices[2][1]] , [this.vertices[0][0], this.vertices[0][1]]] // up
          ]
          
          drawTriangle(this.cx, this.cy, this.id, this.l, 30, 0 + this.rot_degree, "#b49084", "#38445a", "gold", false, "gold");
          let outline1 = document.createElementNS(svgURI, "path");
          let outline_sentence1 = `
                        M ${this.vertices[0][0] } ${this.vertices[0][1]}
                        L ${this.vertices[1][0] } ${this.vertices[1][1]}
                        L ${this.vertices[2][0] } ${this.vertices[2][1]}
                        Z`;
          outline1.setAttribute("d", outline_sentence1);
          outline1.setAttribute("fill", "transparent");
          outline1.setAttribute("stroke", "gold");
          outline1.setAttribute("id", this.id);
          outline1.setAttribute("stroke-width", 0.5);

          svg.appendChild(outline1);
        }
        update(){
            this.vertices = [
                             [this.cx + this.r * Math.cos(this.rot_deg  - 3 * Math.PI/6 + 0 * 2 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  0 * 2 * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  - 3 * Math.PI/6 + 1 * 2 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  1 * 2 * Math.PI/3)]
                            ,[this.cx + this.r * Math.cos(this.rot_deg  - 3 * Math.PI/6 + 2 * 2 *  Math.PI/3), this.cy + this.r * Math.sin(this.rot_deg - 3 * Math.PI/6 +  2 * 2 * Math.PI/3)]

            ];
            this.edges = [ 

                           [[this.vertices[0][0], this.vertices[0][1]] , [this.vertices[1][0], this.vertices[1][1]]] 
                          ,[[this.vertices[1][0], this.vertices[1][1]] , [this.vertices[2][0], this.vertices[2][1]]] 
                          ,[[this.vertices[2][0], this.vertices[2][1]] , [this.vertices[0][0], this.vertices[0][1]]] 
           ]



          if (this.is_collision === false){
            this.cy += 1;
          }




          for (const obj of objList) {
              if (getOverlappingEdge(this, obj) !== null && this.id != obj.id){
              // console.log(getOverlappingEdge(this, obj));
              

              if (this.edges[1] === getOverlappingEdge(this, obj) && this.bottomNeighbor === null){
                console.log("Chihoku!");
                this.bottomNeighbor = obj;
                if(obj.isLinked === true){
                  this.isLinked = true;
                }


                if(this.bottomNeighbor.motive === 'hexagon'){
                  this.cy = obj.cy - 4 /3 *  Math.sin(60 * 2 * Math.PI/ 360) * this.l;
                }
                if(this.bottomNeighbor.motive === 'square'){
                  let sqtri_dist = 1 /3 *  Math.sin(60 * 2 * Math.PI/ 360) * this.l + 0.5 * this.l;
                  this.cy = obj.cy -  sqtri_dist * Math.sin(-obj.rot_deg);
                  console.log(Math.sin(-obj.rot_deg));
                }

                                  this.is_collision = true;
                  break;

              }

              if (this.edges[0] === getOverlappingEdge(this, obj) && this.rightNeighbor === null){
                console.log("Chihoku!");
                this.rightNeighbor = obj;
                                if(obj.isLinked === true){
                  this.isLinked = true;
                }
                if (this.rightNeighbor.motive === 'square'){
                  console.log("Chihochan!");
                  let sqtri_dist = 1 /3 *  Math.sin(60 * 2 * Math.PI/ 360) * this.l + 0.5 * this.l;
                  this.cy = obj.cy -  sqtri_dist * Math.sin(obj.rot_deg);
                  console.log(obj.rot_degree);
                }
                  this.is_collision = true;
                  break;
              }




            }


            if (hasSameEdge(this, obj) && this.id != obj.id) {
              this.is_collision = true;
              break;
            }


            for (let edge1 of this.edges){
              for (let edge2 of obj.edges){
                  if (edgesIntersect(edge1, edge2) === true && this.id != obj.id  ) {
  

                  if (obj.isLinked === true && this.isLinked === true) {
                  console.log("Both objects are linked, continuing...");
                  continue;
                  }

                  if ( ((edge1[0][0] === edge2[1][0] && edge1[0][1] === edge2[1][1]) || (edge1[1][0] === edge2[0][0] && edge1[1][1] === edge2[0][1])) ) {
                  console.log("Shared endpoint detected, skipping...");
                                                console.log("Skipped Objects:", this.id, obj.id);

                  continue;
                  }

                                    if ( !((edge1[0][0] === edge2[1][0] && edge1[0][1] === edge2[1][1]) || (edge1[1][0] === edge2[0][0] && edge1[1][1] === edge2[0][1])) && this.isLinked === false ) {

                        this.is_collision = true;
                        console.log("Chiho Zukky!");
                        console.log(obj);
                        life = false;
                              console.log("Objects that intersects: ", this.id, obj.id);
                              console.log(((edge1[0][0] === edge2[1][0] && edge1[0][1] === edge2[1][1]) || (edge1[1][0] === edge2[0][0] && edge1[1][1] === edge2[0][1])));
                              console.log(edge1, edge2);

                            }


                      
                  }
              }
            }




          }


        }
    }







    function rotateClockwise() {
      rotationAngle = (rotationAngle + 30) % 360; // Increase rotation by 30 degrees
      core.rot_degree = rotationAngle; // Set to the new angle
      core.rot_deg = rotationAngle * 2 * Math.PI / 360; // Update radians
      core.vertices = [
                             [core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 0 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  0   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 1 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  1   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 2 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  2   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 3 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  3   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 4 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  4   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 5 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  5   * Math.PI/3)]
                      ];
      core.edges = [
                           [[core.vertices[0][0], core.vertices[0][1]] , [core.vertices[1][0], core.vertices[1][1]]] // bottom
                          ,[[core.vertices[1][0], core.vertices[1][1]] , [core.vertices[2][0], core.vertices[2][1]]] // bottom left
                          ,[[core.vertices[2][0], core.vertices[2][1]] , [core.vertices[3][0], core.vertices[3][1]]] // upper left
                          ,[[core.vertices[3][0], core.vertices[3][1]] , [core.vertices[4][0], core.vertices[4][1]]] // up
                          ,[[core.vertices[4][0], core.vertices[4][1]] , [core.vertices[5][0], core.vertices[5][1]]] // upper right
                          ,[[core.vertices[5][0], core.vertices[5][1]] , [core.vertices[0][0], core.vertices[0][1]]] // upper left
      ];



      // if (core.upperNeighbor != null) {
      //   core.upperNeighbor.cx = core.cx + core.upperNeighborDist * Math.sin(core.rot_deg );
      //   core.upperNeighbor.cy = core.cy - core.upperNeighborDist * Math.cos(core.rot_deg );
      //   core.upperNeighbor.rot_degree = core.rot_degree;
      //   core.upperNeighbor.rot_deg = core.rot_deg; 
      //   core.upperNeighbor.update();
      // }

      // if (core.upperLeftNeighbor != null) {
      //   core.upperLeftNeighbor.cx = core.cx + core.upperLeftNeighborDist * Math.sin(core.rot_deg - Math.PI/3 );
      //   core.upperLeftNeighbor.cy = core.cy - core.upperLeftNeighborDist * Math.cos(core.rot_deg - Math.PI/3 );
      //   core.upperLeftNeighbor.rot_degree = core.rot_degree - 60;
      //   core.upperLeftNeighbor.rot_deg = core.rot_deg - Math.PI/3; 
      //   core.upperLeftNeighbor.update();
      // }
      // if (core.bottomLeftNeighbor != null) {
      //   core.bottomLeftNeighbor.cx = core.cx + core.bottomLeftNeighborDist * Math.sin(core.rot_deg - 2 * Math.PI/3 );
      //   core.bottomLeftNeighbor.cy = core.cy - core.bottomLeftNeighborDist * Math.cos(core.rot_deg - 2 * Math.PI/3 );
      //   core.bottomLeftNeighbor.rot_degree = core.rot_degree - 2 * 60;
      //   core.bottomLeftNeighbor.rot_deg = core.rot_deg - 2 * Math.PI/3; 
      //   core.bottomLeftNeighbor.update();
      // }

      // if (core.bottomNeighbor != null) {
      //   core.bottomNeighbor.cx = core.cx + core.bottomNeighborDist * Math.sin(core.rot_deg - 3 * Math.PI/3 );
      //   core.bottomNeighbor.cy = core.cy - core.bottomNeighborDist * Math.cos(core.rot_deg - 3 * Math.PI/3 );
      //   core.bottomNeighbor.rot_degree = core.rot_degree - 3 * 60;
      //   core.bottomNeighbor.rot_deg = core.rot_deg - 3 * Math.PI/3; 
      //   core.bottomNeighbor.update();
      // }

      // if (core.upperRightNeighbor != null) {
      //   core.upperRightNeighbor.cx = core.cx + core.upperRightNeighborDist * Math.sin(core.rot_deg + Math.PI/3 );
      //   core.upperRightNeighbor.cy = core.cy - core.upperRightNeighborDist * Math.cos(core.rot_deg + Math.PI/3 );
      //   core.upperRightNeighbor.rot_degree = core.rot_degree + 60;
      //   core.upperRightNeighbor.rot_deg = core.rot_deg + Math.PI/3; 
      //   core.upperRightNeighbor.update();
      // }

      // if (core.bottomRightNeighbor != null) {
      //   core.bottomRightNeighbor.cx = core.cx + core.bottomRightNeighborDist * Math.sin(core.rot_deg + 2 * Math.PI/3 );
      //   core.bottomRightNeighbor.cy = core.cy - core.bottomRightNeighborDist * Math.cos(core.rot_deg + 2 * Math.PI/3 );
      //   core.bottomRightNeighbor.rot_degree = core.rot_degree + 2 * 60;
      //   core.bottomRightNeighbor.rot_deg = core.rot_deg + 2 * Math.PI/3; 
      //   core.bottomRightNeighbor.update();
      // }


      // for (let obj of objList){
      //   if (obj.motive === 'triangle' && ( (obj.bottomNeighbor != null && obj.bottomNeighbor.id != 'core')  || (obj.rightNeighbor != null && obj.rightNeighbor.id != 'core')  )){
      //     let dist = Math.sqrt((core.cx - obj.cx)**2 + (core.cy - obj.cy) **2);
      //     let deg = Math.atan2((core.cy - obj.cy), (core.cx - obj.cx));

      //     obj.cx = core.cx - dist * Math.cos(deg + Math.PI/6 );
      //     obj.cy = core.cy - dist * Math.sin(deg + Math.PI/6 );
      //     obj.rot_degree = obj.rot_degree + 30;
      //     obj.rot_deg = obj.rot_deg + Math.PI/6; 
      //     obj.update();

      //     console.log(deg * 180 / Math.PI);
      //   }
      // }

            for (let obj of objList){
        // if (obj.motive === 'triangle' && ( (obj.bottomNeighbor != null && obj.bottomNeighbor.id != 'core')  || (obj.rightNeighbor != null && obj.rightNeighbor.id != 'core')  )){
        //   let dist = Math.sqrt((core.cx - obj.cx)**2 + (core.cy - obj.cy) **2);
        //   let deg = Math.atan2((core.cy - obj.cy), (core.cx - obj.cx));

        //   obj.cx = core.cx - dist * Math.cos(deg + Math.PI/6 );
        //   obj.cy = core.cy - dist * Math.sin(deg + Math.PI/6 );
        //   obj.rot_degree = obj.rot_degree + 30;
        //   obj.rot_deg = obj.rot_deg + Math.PI/6; 
        //   obj.update();

        //   console.log(deg * 180 / Math.PI);
        // }

        if (obj.isLinked === true && obj.id !== 'core'){
          console.log("Chihooooo Channnnn");
          console.log(obj);
          let dist = Math.sqrt((core.cx - obj.cx)**2 + (core.cy - obj.cy) **2);
          let deg = Math.atan2((core.cy - obj.cy), (core.cx - obj.cx));
          obj.cx = core.cx - dist * Math.cos(deg + Math.PI/6 );
          obj.cy = core.cy - dist * Math.sin(deg + Math.PI/6 );
          obj.rot_degree = obj.rot_degree + 30;
          obj.rot_deg = obj.rot_deg + Math.PI/6; 
          obj.update();

          console.log(deg * 180 / Math.PI);
        }


      }

        
      console.log("chiho!");
    }
    
    function rotateCounterClockwise() {
      rotationAngle = (rotationAngle - 30 + 360) % 360; // Decrease rotation by 30 degrees, ensuring no negative angles
      core.rot_degree = rotationAngle; // Set to the new angle
      core.rot_deg = rotationAngle * 2 * Math.PI / 360; // Update radians
      core.vertices = [
                             [core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 0 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  0   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 1 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  1   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 2 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  2   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 3 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  3   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 4 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  4   * Math.PI/3)]
                            ,[core.cx + core.r * Math.cos(core.rot_deg  + Math.PI/3 + 5 *  Math.PI/3), core.cy + core.r * Math.sin(core.rot_deg + Math.PI/3 +  5   * Math.PI/3)]
                      ];
      core.edges = [
                           [[core.vertices[0][0], core.vertices[0][1]] , [core.vertices[1][0], core.vertices[1][1]]] // bottom
                          ,[[core.vertices[1][0], core.vertices[1][1]] , [core.vertices[2][0], core.vertices[2][1]]] // bottom left
                          ,[[core.vertices[2][0], core.vertices[2][1]] , [core.vertices[3][0], core.vertices[3][1]]] // upper left
                          ,[[core.vertices[3][0], core.vertices[3][1]] , [core.vertices[4][0], core.vertices[4][1]]] // up
                          ,[[core.vertices[4][0], core.vertices[4][1]] , [core.vertices[5][0], core.vertices[5][1]]] // upper right
                          ,[[core.vertices[5][0], core.vertices[5][1]] , [core.vertices[0][0], core.vertices[0][1]]] // upper left
      ];


      // if (core.upperNeighbor != null) {
      //   core.upperNeighbor.cx = core.cx + core.upperNeighborDist * Math.sin(core.rot_deg );
      //   core.upperNeighbor.cy = core.cy - core.upperNeighborDist * Math.cos(core.rot_deg );
      //   core.upperNeighbor.rot_degree = core.rot_degree;
      //   core.upperNeighbor.rot_deg = core.rot_deg; 
      //   core.upperNeighbor.update();
      // }


      // if (core.upperLeftNeighbor != null) {
      //   core.upperLeftNeighbor.cx = core.cx + core.upperLeftNeighborDist * Math.sin(core.rot_deg - Math.PI/3 );
      //   core.upperLeftNeighbor.cy = core.cy - core.upperLeftNeighborDist * Math.cos(core.rot_deg - Math.PI/3 );
      //   core.upperLeftNeighbor.rot_degree = core.rot_degree - 60;
      //   core.upperLeftNeighbor.rot_deg = core.rot_deg - Math.PI/3; 
      //   core.upperLeftNeighbor.update();
      // }

      // if (core.bottomLeftNeighbor != null) {
      //   core.bottomLeftNeighbor.cx = core.cx + core.bottomLeftNeighborDist * Math.sin(core.rot_deg - 2 * Math.PI/3 );
      //   core.bottomLeftNeighbor.cy = core.cy - core.bottomLeftNeighborDist * Math.cos(core.rot_deg - 2 * Math.PI/3 );
      //   core.bottomLeftNeighbor.rot_degree = core.rot_degree - 2 * 60;
      //   core.bottomLeftNeighbor.rot_deg = core.rot_deg - 2 * Math.PI/3; 
      //   core.bottomLeftNeighbor.update();
      // }

      // if (core.bottomNeighbor != null) {
      //   core.bottomNeighbor.cx = core.cx + core.bottomNeighborDist * Math.sin(core.rot_deg - 3 * Math.PI/3 );
      //   core.bottomNeighbor.cy = core.cy - core.bottomNeighborDist * Math.cos(core.rot_deg - 3 * Math.PI/3 );
      //   core.bottomNeighbor.rot_degree = core.rot_degree - 3 * 60;
      //   core.bottomNeighbor.rot_deg = core.rot_deg - 3 * Math.PI/3; 
      //   core.bottomNeighbor.update();
      // }

      // if (core.upperRightNeighbor != null) {
      //   core.upperRightNeighbor.cx = core.cx + core.upperRightNeighborDist * Math.sin(core.rot_deg + Math.PI/3 );
      //   core.upperRightNeighbor.cy = core.cy - core.upperRightNeighborDist * Math.cos(core.rot_deg + Math.PI/3 );
      //   core.upperRightNeighbor.rot_degree = core.rot_degree + 60;
      //   core.upperRightNeighbor.rot_deg = core.rot_deg + Math.PI/3; 
      //   core.upperRightNeighbor.update();
      // }

      // if (core.bottomRightNeighbor != null) {
      //   core.bottomRightNeighbor.cx = core.cx + core.bottomRightNeighborDist * Math.sin(core.rot_deg + 2 * Math.PI/3 );
      //   core.bottomRightNeighbor.cy = core.cy - core.bottomRightNeighborDist * Math.cos(core.rot_deg + 2 * Math.PI/3 );
      //   core.bottomRightNeighbor.rot_degree = core.rot_degree + 2 * 60;
      //   core.bottomRightNeighbor.rot_deg = core.rot_deg + 2 * Math.PI/3; 
      //   core.bottomRightNeighbor.update();
      // }


        for (let obj of objList){


        // if (obj.motive === 'triangle' && ( (obj.bottomNeighbor != null && obj.bottomNeighbor.id != 'core')  || (obj.rightNeighbor != null && obj.rightNeighbor.id != 'core')  )){
        //   let dist = Math.sqrt((core.cx - obj.cx)**2 + (core.cy - obj.cy) **2);
        //   let deg = Math.atan2((core.cy - obj.cy), (core.cx - obj.cx));

        //   obj.cx = core.cx - dist * Math.cos(deg -  Math.PI/6 );
        //   obj.cy = core.cy - dist * Math.sin(deg -  Math.PI/6 );
        //   obj.rot_degree = obj.rot_degree - 30;
        //   obj.rot_deg = obj.rot_deg - Math.PI/6; 
        //   obj.update();

        //   console.log(deg * 180 / Math.PI);
        // }
        if (obj.isLinked === true && obj.id !== 'core'){
          console.log("Chihooooo Channnnn");
          console.log(obj);
          let dist = Math.sqrt((core.cx - obj.cx)**2 + (core.cy - obj.cy) **2);
          let deg = Math.atan2((core.cy - obj.cy), (core.cx - obj.cx));
          obj.cx = core.cx - dist * Math.cos(deg - Math.PI/6 );
          obj.cy = core.cy - dist * Math.sin(deg - Math.PI/6 );
          obj.rot_degree = obj.rot_degree - 30;
          obj.rot_deg = obj.rot_deg - Math.PI/6; 
          obj.update();

          console.log(deg * 180 / Math.PI);
        }


      }


    }

    // Add event listeners for key presses
    document.addEventListener('keydown', (event) => {
    if (event.key === 'ArrowRight') {
      rotateClockwise();
    } else if (event.key === 'ArrowLeft') {
      rotateCounterClockwise();
    }
    });










    // Initialize the Game
    let objList = [];
    const cx = svg.getAttribute("width") / 2;
    const unitSize = svg.getAttribute("width") / 8;

    
    // let core = new TriangleTumpal(200, 250, 65, 'triangle', 0, 'tr');
    // objList.push(core);



    // let hint = new HintGuideline(200, 450 - Math.tan(60/360 * 2 * Math.PI) * (65), 65 * 3, 'hint', 0 + rotationAngle, 'hint');
    // objList.push(hint);



    let core = new HexagonTumpal(cx, 450, unitSize, 'hexagon', 0 + rotationAngle, 'core');
    objList.push(core);


    let sq = new SquareTumpal(cx, 200, unitSize, 'square', 0, 'sq');
    objList.push(sq);

    let sq2 = new SquareTumpal(cx, 0, unitSize, 'square', 0, 'sq2');
    objList.push(sq2);

    let tri = new TriangleTumpal(cx, -200, unitSize, 'triangle', 60, 'tr');
    objList.push(tri);


    let sq3 = new SquareTumpal(cx, -400, unitSize, 'square', 0, 'sq3');
    objList.push(sq3);

    let sq4 = new SquareTumpal(cx, -600, unitSize, 'square', 0, 'sq4');
    objList.push(sq4);

    let sq5 = new SquareTumpal(cx, -1000, unitSize, 'square', 0, 'sq5');
    objList.push(sq5);

    let sq6 = new SquareTumpal(cx, -800, unitSize, 'square', 0, 'sq6');
    objList.push(sq6);



    let tri2 = new TriangleTumpal(cx, -1200, unitSize, 'triangle', 60, 'tr2');
    objList.push(tri2);

    let tri3 = new TriangleTumpal(cx, -1400, unitSize, 'triangle', 60, 'tr3');
    objList.push(tri3);

    let tri4 = new TriangleTumpal(cx, -1600, unitSize, 'triangle', 60, 'tr4');
    objList.push(tri4);

    let tri5 = new TriangleTumpal(cx, -1800, unitSize, 'triangle', 60, 'tr5');
    objList.push(tri5);

    let tri6 = new TriangleTumpal(cx, -2000, unitSize, 'triangle', 60, 'tr6');
    objList.push(tri6);




    // let tri = new TriangleTumpal(200, 100, unitSize, 'triangle', 0, 'tr');
    // objList.push(tri);

    // let tri2 = new TriangleTumpal(200, -100, unitSize, 'triangle', 0, 'tr2');
    // objList.push(tri2);

    // let tri3 = new TriangleTumpal(200, -300, unitSize, 'triangle', 0, 'tr3');
    // objList.push(tri3);




    // Game loop
    function gameLoop() {
      // removeSvgChildById(svg, 'core');
      // removeSvgChildById(svg, 'sq');
      // `container-${Date.now()}-${Math.floor(Math.random() * 1000000)}`
      for (obj of objList){
        removeSvgChildById(svg, obj.id);
        obj.update();
        obj.draw();
      }

        removeSvgChildById(svg, 'hint');
        drawHint(cx, 450, 'hint', unitSize, 0, 15 + core.rot_degree, "none", "none", "white");






  const coreHasTriangles = (
    core.bottomNeighbor?.motive === 'square' && 
    core.upperNeighbor?.motive === 'square' &&
    core.upperLeftNeighbor?.motive === 'square' &&
    core.bottomLeftNeighbor?.motive === 'square' &&
    core.upperRightNeighbor?.motive === 'square' &&
    core.bottomRightNeighbor?.motive === 'square' && 
    (tri.rightNeighbor?.motive === 'square' || tri.bottomNeighbor?.motive === 'square') && 
    (tri2.rightNeighbor?.motive === 'square' || tri2.bottomNeighbor?.motive === 'square') && 
    (tri3.rightNeighbor?.motive === 'square' || tri3.bottomNeighbor?.motive === 'square') && 
    (tri4.rightNeighbor?.motive === 'square' || tri4.bottomNeighbor?.motive === 'square') && 
    (tri5.rightNeighbor?.motive === 'square' || tri5.bottomNeighbor?.motive === 'square') && 
    (tri6.rightNeighbor?.motive === 'square' || tri6.bottomNeighbor?.motive === 'square') 


  );


  if (coreHasTriangles) {
    const text2 = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text2.setAttribute("x", "50%");
    text2.setAttribute("y", "85%");
    text2.setAttribute("text-anchor", "middle");
    text2.setAttribute("dominant-baseline", "middle");
    text2.setAttribute("fill", "white");
    text2.setAttribute("font-size", "40");
    text2.setAttribute("font-family", "Arial, sans-serif");
    text2.textContent = "Game Clear!";
    svg.appendChild(text2); // Append the "Game Clear" text to the SVG
    removeSvgChildById(svg, 'textTutorialInit');
    removeSvgChildById(svg, 'textTutorialInit2');
    playGameClear()
  }

      



      if (life === false){
        playCrash();
        let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", "50%");
        text.setAttribute("y", "50%");
        text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.setAttribute("fill", "white");
    text.setAttribute("font-size", "20");
    text.setAttribute("font-family", "Arial, sans-serif");
    text.textContent = "Game Over. Press any key to retry";
        // Append the text to the SVG
        svg.appendChild(text);

            function waitForUserInput(callback) {
    const handleUserInput = (event) => {
              console.log("User input received:", event.type, event.key);

        document.removeEventListener("keydown", handleUserInput);
        document.removeEventListener("click", handleUserInput);
        callback(); // Proceed with the game logic
    };

    // Add event listeners only if they're not already attached
    document.removeEventListener("keydown", handleUserInput);
    document.removeEventListener("click", handleUserInput);

    document.addEventListener("keydown", handleUserInput);
    document.addEventListener("click", handleUserInput);
    }

    // Insert Pause and wait for input before continue the statement
    waitForUserInput(() => {
    location.reload(true);    
    });

    
      }

      if (life === true && !coreHasTriangles){
        requestAnimationFrame(gameLoop);
      }

      
    }


        function waitForGameStart(callback) {
    const handleUserInput = (event) => {

        document.removeEventListener("keydown", handleUserInput);
        document.removeEventListener("click", handleUserInput);
        callback(); // Proceed with the game logic
    };

    // Add event listeners only if they're not already attached
    document.removeEventListener("keydown", handleUserInput);
    document.removeEventListener("click", handleUserInput);

    document.addEventListener("keydown", handleUserInput);
    document.addEventListener("click", handleUserInput);
    }



    const text2 = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text2.setAttribute("x", "50%");
    text2.setAttribute("y", "50%");
    text2.setAttribute("id", "waitStart");
    text2.setAttribute("text-anchor", "middle");
    text2.setAttribute("dominant-baseline", "middle");
    text2.setAttribute("fill", "white");
    text2.setAttribute("font-size", "20");
    text2.setAttribute("font-family", "Arial, sans-serif");
    text2.textContent = "Level 2: Elusive Dodecagon ";
    svg.appendChild(text2); // Append the "Game Clear" text to the SVG


    const text3 = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text3.setAttribute("x", "50%");
    text3.setAttribute("y", "60%");
    text3.setAttribute("id", "waitStart");
    text3.setAttribute("text-anchor", "middle");
    text3.setAttribute("dominant-baseline", "middle");
    text3.setAttribute("fill", "white");
    text3.setAttribute("font-size", "20");
    text3.setAttribute("font-family", "Arial, sans-serif");
    text3.textContent = "Click or tap to start ";
    svg.appendChild(text3); // Append the "Game Clear" text to the SVG



    // Insert Pause and wait for input before continue the statement
    waitForGameStart(() => {
    removeSvgChildById(svg, 'waitStart');
    gameLoop();
    });



    // Start the game
    // gameLoop();
  </script>
</body>
</html>
